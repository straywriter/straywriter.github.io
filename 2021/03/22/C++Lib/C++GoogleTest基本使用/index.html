<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"straywriter.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="C++ GoogleTest基本使用">
<meta property="og:url" content="https://straywriter.github.io/2021/03/22/C++Lib/C++GoogleTest%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-22T13:59:11.315Z">
<meta property="article:modified_time" content="2021-05-17T15:01:41.904Z">
<meta property="article:author" content="straywriter">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://straywriter.github.io/2021/03/22/C++Lib/C++GoogleTest%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++ GoogleTest基本使用 | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://straywriter.github.io/2021/03/22/C++Lib/C++GoogleTest%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="straywriter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ GoogleTest基本使用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-22 21:59:11" itemprop="dateCreated datePublished" datetime="2021-03-22T21:59:11+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-17 23:01:41" itemprop="dateModified" datetime="2021-05-17T23:01:41+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<h2 id="断言assertions">断言(Assertions)</h2>
<ul>
<li><p>GTEST的断言是类似函数调用的宏定义，对类或者函数使用断言来判断它的行为。当一个断言失败了，GTEST会打印这个测试断言的源文件、行数以及失败信息。也可以提供定制的错误信息接在GTEST的错误信息后面。</p></li>
<li><p><code>ASSERT_*</code>和<code>EXPECT_*</code>这两种断言成对出现，用来测试相同的东西，但是对当前函数有不同的影响。</p></li>
<li><p><code>ASSERT_*</code>版本在断言失败时产生致命错误，并且终止当前函数。</p></li>
<li><p><code>EXPECT_*</code>版本则产生非致命错误，且不会终止当前函数。</p></li>
<li><p>通常更倾向于使用<code>EXPECT_*</code>，因为这样能够允许在一个测试用例中报告多个错误。如果断言继续下去没有意义的话，就应该使用<code>ASSERT_*</code>进行判断。</p></li>
<li><p><code>ASSERT_*</code>立刻从当前函数返回，可能会跳过之后的清理代码，这将会导致空间泄漏。根据泄漏的性质，它可能值得修复，也可能不值得修复。因此，如果除了断言错误外还出现堆检查器错误，请记住检查这一点。</p></li>
</ul>
<p>使用<code>&lt;&lt;</code>符号来将自定义的错误信息添加进宏里面，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASSERT_EQ(x.size(), y.size()) &lt;&lt; <span class="string">&quot;Vectors x and y are of unequal length&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.size(); ++i) &#123;</span><br><span class="line">  EXPECT_EQ(x[i], y[i]) &lt;&lt; <span class="string">&quot;Vectors x and y differ at index &quot;</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本的断言">基本的断言</h3>
<p>判断真假的断言</p>
<table>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_TRUE(condition);</code></td>
<td><code>EXPECT_TRUE(condition);</code></td>
<td><code>condition</code> is true</td>
</tr>
<tr class="even">
<td><code>ASSERT_FALSE(condition);</code></td>
<td><code>EXPECT_FALSE(condition);</code></td>
<td><code>condition</code> is false</td>
</tr>
</tbody>
</table>
<h3 id="比较断言">比较断言</h3>
<p>这类断言用来比较两个值</p>
<table>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_EQ(val1, val2);</code></td>
<td><code>EXPECT_EQ(val1, val2);</code></td>
<td><code>val1 == val2</code></td>
</tr>
<tr class="even">
<td><code>ASSERT_NE(val1, val2);</code></td>
<td><code>EXPECT_NE(val1, val2);</code></td>
<td><code>val1 != val2</code></td>
</tr>
<tr class="odd">
<td><code>ASSERT_LT(val1, val2);</code></td>
<td><code>EXPECT_LT(val1, val2);</code></td>
<td><code>val1 &lt; val2</code></td>
</tr>
<tr class="even">
<td><code>ASSERT_LE(val1, val2);</code></td>
<td><code>EXPECT_LE(val1, val2);</code></td>
<td><code>val1 &lt;= val2</code></td>
</tr>
<tr class="odd">
<td><code>ASSERT_GT(val1, val2);</code></td>
<td><code>EXPECT_GT(val1, val2);</code></td>
<td><code>val1 &gt; val2</code></td>
</tr>
<tr class="even">
<td><code>ASSERT_GE(val1, val2);</code></td>
<td><code>EXPECT_GE(val1, val2);</code></td>
<td><code>val1 &gt;= val2</code></td>
</tr>
</tbody>
</table>
<ul>
<li><p>断言参数的值必须是可比较的，否则会产生一个编译错误。</p></li>
<li><p>当断言失败时，如果自定义的错误支持<code>&lt;&lt;</code>运算符，那么GTEST将会打印他们，否则将会尝试用其他的方式打印出他们。</p></li>
<li><p>用户自定义类型仅仅当定义了比较操作时，断言才能够比较的对象的大小，但是这不被Google的C++类型规范所提倡，这种情况下应当使用<code>ASSERT_TRUE()</code>或者<code>EXPECT_TRUE()</code>来进行判断。</p></li>
<li><p>不过还是应当尽可能的使用<code>ASSERT_EQ(actual, expected)</code>，因为他能够在测试失败时告知<code>actual</code>和<code>expected</code>的值。</p></li>
<li><p><code>ASSERT_EQ()</code>在比较指针时比较的是指针的值，当比较两个C风格的字符串时，将会比较他们是否有相同的内存地址，而不是有相同的值。因此在比较C风格字符串的时候应当使用<code>ASSERT_STREQ()</code>，但是在比较两个string对象的时候，应当使用<code>ASSERT_EQ</code>。</p></li>
<li><p>在进行指针的比较时应当使用<code>*_EQ(ptr, nullptr)</code>和<code>*_NE(ptr, nullptr)</code>代替<code>*_EQ(ptr, NULL)</code>和<code>*_NE(ptr, NULL)</code>，因为<code>nullptr</code>被定义了类型而<code>NULL</code>却没有。</p></li>
<li><p>当比较浮点数时应该使用浮点数断言来避免近似值导致的问题。</p></li>
<li><p>本节的宏定义对<code>string</code>和<code>wstring</code>都适用。</p></li>
</ul>
<h3 id="字符串比较">字符串比较</h3>
<p>这节的断言用来比较C语言风格的字符串，在比较两个string对象时，应该使用<code>EXPECT_EQ</code>,<code>EXPECT_NE</code>。</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_STREQ(str1,str2);</code></td>
<td><code>EXPECT_STREQ(str1,str2);</code></td>
<td>the two C strings have the same content</td>
</tr>
<tr class="even">
<td><code>ASSERT_STRNE(str1,str2);</code></td>
<td><code>EXPECT_STRNE(str1,str2);</code></td>
<td>the two C strings have different contents</td>
</tr>
<tr class="odd">
<td><code>ASSERT_STRCASEEQ(str1,str2);</code></td>
<td><code>EXPECT_STRCASEEQ(str1,str2);</code></td>
<td>the two C strings have the same content, ignoring case</td>
</tr>
<tr class="even">
<td><code>ASSERT_STRCASENE(str1,str2);</code></td>
<td><code>EXPECT_STRCASENE(str1,str2);</code></td>
<td>the two C strings have different contents, ignoring case</td>
</tr>
</tbody>
</table>
<p><strong>注意：“CASE”表明忽略大小写，一个<code>NULL</code>指针和空字符串不一样</strong></p>
<h3 id="简单的测试例子">简单的测试例子</h3>
<p>创建一个测试：</p>
<ol type="1">
<li>使用<code>TEST()</code>宏定义来定义和命名一个测试函数，这些宏就是没有返回值的普通C++函数。</li>
<li>在这个函数中，可以包含任何有效的c++语句中，使用各种GTEST断言来检查值。</li>
<li>测试结果由断言决定；如果测试中的任何断言失败(致命或非致命)，或者测试崩溃，则整个测试失败。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEST(TestSuiteName, TestName) &#123;</span><br><span class="line">  ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>TEST()</code>的第一个参数是测试套件（Test Suite）的名称，第二个参数是这个测试套件中该测试（Test）的名称。</li>
<li>两种名称都必须是合法的C++标识符，并且不能包含任何下划线<code>_</code>。不同测试套件中的测试可以有相同的名字。</li>
</ul>
<p>举个例子，被测函数是一个简单的斐波那契函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>;  <span class="comment">// Returns the factorial of n</span></span><br></pre></td></tr></table></figure>
<p>一个测试可以写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tests factorial of 0.</span></span><br><span class="line">TEST(FactorialTest, HandlesZeroInput) &#123;</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of positive numbers.</span></span><br><span class="line">TEST(FactorialTest, HandlesPositiveInput) &#123;</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">2</span>), <span class="number">2</span>);</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">3</span>), <span class="number">6</span>);</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">8</span>), <span class="number">40320</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑上来说，相关的测试应该在同一个测试套件（Test Suite）中。在上述的例子中，有两个测试<code>HandlesZeroInput</code>和<code>HandlesPositiveInput</code>，他们属于同一个测试套件<code>FactorialTest</code>。</p>
<h2 id="test-fixtures为多个测试使用相同的配置">Test Fixtures(为多个测试使用相同的配置)</h2>
<p>当两个或更多的测试需要使用相似的数据时，可以使用<em>Test Fixture</em>。这可以对不同的测试重用相同的数据对象配置。</p>
<p>创建一个fixture：</p>
<ol type="1">
<li>从<code>::testing::Test</code>派生出一个类。用<code>protected:</code>开始它的类主体，因为需要从子类访问fixture成员。</li>
<li>在类中声明所有准备使用的对象</li>
<li>如果需要，可以编写一个默认构造函数或<code>SetUp()</code>函数来为每个测试准备对象。常见的错误是将<code>SetUp()</code>拼写为<code>Setup()</code>，在c++ 11中可以使用<code>override</code>来确保拼写正确。</li>
<li>如有必要，编写一个析构函数或<code>TearDown()</code>函数以释放您在<code>SetUp()</code>中分配的所有资源。 若要了解何时应使用构造函数/析构函数以及何时应使用<code>SetUp()/ TearDown()</code>。</li>
<li>如果需要，定义要共享的测试的子程序。</li>
</ol>
<p>当使用fixture时，使用<code>TEST_F()</code>代替<code>TEST()</code>，因为<code>TEST_F()</code>允许你在Test Fixture中获取对象和子程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEST_F(TestFixtureName, TestName) &#123;</span><br><span class="line">  ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>TEST()</code>类似，第一个参数是测试套件的名字，但是<code>TEST_F()</code>的这个参数必须和<code>Test Fixture</code>类的名字相同。还需要在使用<code>Test Fixture</code>对象之前定义这个<code>Test Fixture</code>类，否则会导致编译错误<code>virtual outside class declaration</code>。</p>
<p>对于每个<code>TEST_F()</code>来说，GTEST在运行时都会创建一个新的test fixture对象，并且通过<code>SetUp()</code>立刻初始化这个对象，再运行测试，结束后通过调用<code>TearDown()</code>来进行清理工作，最后将删除这个test fixture对象。注意，在同一个测试套件中的不同测试拥有不同的test fixture对象，GTEST在新建下一个test fixture对象时总是会先删除上一个test fixture对象，并且不会在多个不同的测试中重用一个test fixture对象。所以如果任何测试改变了它的test fixture对象，并不会影响其他测试的test fixture对象。</p>
<p>下面用对一个FIFO队列类<code>Queue</code>编写测试，他有以下接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;  <span class="comment">// E is the element type.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Queue();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(<span class="keyword">const</span> E&amp; element)</span></span>;</span><br><span class="line">  <span class="function">E* <span class="title">Dequeue</span><span class="params">()</span></span>;  <span class="comment">// Returns NULL if the queue is empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个fixture类。按照惯例，应该给它起一个<code>FooTest</code>的名字，其中<code>Foo</code>是被测试的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">     q1_.Enqueue(<span class="number">1</span>);</span><br><span class="line">     q2_.Enqueue(<span class="number">2</span>);</span><br><span class="line">     q2_.Enqueue(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// void TearDown() override &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q0_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q1_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q2_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，不需要<code>TearDown()</code>函数，因为析构器已经完成了析构工作，不需要再进行清理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TEST_F(QueueTest, IsEmptyInitially) &#123;</span><br><span class="line">  EXPECT_EQ(q0_.size(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST_F(QueueTest, DequeueWorks) &#123;</span><br><span class="line">  <span class="keyword">int</span>* n = q0_.Dequeue();</span><br><span class="line">  EXPECT_EQ(n, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  n = q1_.Dequeue();</span><br><span class="line">  ASSERT_NE(n, <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(*n, <span class="number">1</span>);</span><br><span class="line">  EXPECT_EQ(q1_.size(), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line"></span><br><span class="line">  n = q2_.Dequeue();</span><br><span class="line">  ASSERT_NE(n, <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(*n, <span class="number">2</span>);</span><br><span class="line">  EXPECT_EQ(q2_.size(), <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面使用了<code>ASSERT_*</code>和<code>EXPECT_*</code>断言。当希望测试在断言失败后继续显示更多错误时使用<code>EXPECT_*</code>，而在失败后继续运行测试没有意义则使用<code>ASSERT_*</code>。</li>
<li>例如，Dequeue测试中的第二个断言是<code>ASSERT_NE(nullptr, n)</code>，因为我们稍后需要对指针<code>n</code>进行解引用，这将在<code>n</code>的值为<code>NULL</code>时导致段错误。</li>
</ul>
<p>当测试运行时，以下步骤将会发生：</p>
<ol type="1">
<li>GTEST构建一个<code>QueueTest</code>对象<code>t1</code></li>
<li><code>t1.SetUp()</code>初始化<code>t1</code></li>
<li>第一个测试在<code>t1</code>上运行</li>
<li><code>t1.TearDown()</code>在第一个测试结束时进行清理</li>
<li>析构<code>t1</code></li>
<li>在进行另外一个<code>QueueTest</code>对象测试<code>DequeueWorks</code>测试时，重复上述步骤</li>
</ol>
<h2 id="调用测试">调用测试</h2>
<ul>
<li><code>TEST()</code>和<code>TEST_F()</code>向googletest隐式注册其测试。与许多其他C ++测试框架不同，不必重新列出所有已定义的测试即可运行它们。</li>
<li>定义测试后，可以使用<code>RUN_ALL_TESTS()</code>运行它们，如果所有测试成功，将返回0，否则返回1。<code>RUN_ALL_TESTS()</code>在链接单元中运行所有测试，它们可以来自不同的测试套件，甚至来自不同的源文件。</li>
</ul>
<p>当调用<code>RUN_ALL_TESTS()</code>宏时：</p>
<ul>
<li>保存所有GTEST标志的状态</li>
<li>为第一个测试创建一个test fixture对象</li>
<li>通过<code>SetUp()</code>初始化这个对象</li>
<li>在fixture对象上运行测试</li>
<li>通过<code>TearDown()</code>函数进行清理</li>
<li>删除fixture对象</li>
<li>恢复所有GTEST标志的状态</li>
<li>重复上述步骤直到测试结束</li>
</ul>
<p><strong>当一个致命性的错误发生时，后续的步骤将会被跳过。</strong></p>
<blockquote>
<p>重要说明：一定不能忽略<code>RUN_ALL_TESTS()</code>的返回值，否则会出现编译器错误。 这种设计的基本原理是，自动化测试服务将根据其退出代码（而不是根据其stdout / stderr输出）来确定测试是否通过。 因此<code>main()</code>函数必须返回<code>RUN_ALL_TESTS()</code>的值。</p>
<p>另外，您应该只调用一次<code>RUN_ALL_TESTS()</code>。 多次调用它会与某些高级googletest功能（例如线程安全的死亡测试）发生冲突，因此不被支持。</p>
</blockquote>
<h2 id="编写main函数">编写main()函数</h2>
<p><code>gtest_main</code>库提供了一个合适的程序入口点，通过链接<code>gtest_main</code>动态库而不是<code>gtest</code>库，<strong>大多用户无需编写他们自己的main函数</strong>(Google Test提供了<code>main()</code>函数的基本实现。</p>
<p>如果适合你的需求，则只需将测试与gtest_main库链接就可以了。本节的其余部分仅适用于需要在测试运行前做一些自定义的事情，而这些事情不能在test fixture和测试套件的框架内表达。</p>
<p>如果您编写自己的<code>main()</code>函数，则该函数应返回<code>RUN_ALL_TESTS()</code>的值。</p>
<p>下面是一个模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;this/package/foo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> my &#123;</span><br><span class="line"><span class="keyword">namespace</span> project &#123;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The fixture for testing class Foo.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// You can remove any or all of the following functions if their bodies would</span></span><br><span class="line">  <span class="comment">// be empty.</span></span><br><span class="line"></span><br><span class="line">  FooTest() &#123;</span><br><span class="line">     <span class="comment">// You can do set-up work for each test here.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~FooTest() <span class="keyword">override</span> &#123;</span><br><span class="line">     <span class="comment">// You can do clean-up work that doesn&#x27;t throw exceptions here.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the constructor and destructor are not enough for setting up</span></span><br><span class="line">  <span class="comment">// and cleaning up each test, you can define the following methods:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Code here will be called immediately after the constructor (right</span></span><br><span class="line">     <span class="comment">// before each test).</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Code here will be called immediately after each test (right</span></span><br><span class="line">     <span class="comment">// before the destructor).</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Class members declared here can be used by all tests in the test suite</span></span><br><span class="line">  <span class="comment">// for Foo.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests that the Foo::Bar() method does Abc.</span></span><br><span class="line">TEST_F(FooTest, MethodBarDoesAbc) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> input_filepath = <span class="string">&quot;this/package/testdata/myinputfile.dat&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> output_filepath = <span class="string">&quot;this/package/testdata/myoutputfile.dat&quot;</span>;</span><br><span class="line">  Foo f;</span><br><span class="line">  EXPECT_EQ(f.Bar(input_filepath, output_filepath), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests that Foo does Xyz.</span></span><br><span class="line">TEST_F(FooTest, DoesXyz) &#123;</span><br><span class="line">  <span class="comment">// Exercises the Xyz feature of Foo.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line">&#125;  <span class="comment">// namespace project</span></span><br><span class="line">&#125;  <span class="comment">// namespace my</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  ::testing::InitGoogleTest(&amp;argc, argv);</span><br><span class="line">  <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>:: testing :: InitGoogleTest()</code>函数解析命令行中的googletest标志，并删除所有可识别的标志。</li>
<li>这允许用户通过各种标志控制测试程序的行为，将在AdvancedGuide中介绍这些标志。</li>
<li>注意，必须在调用<code>RUN_ALL_TESTS()</code>之前调用该函数，否则标志将无法正确初始化。</li>
</ul>
<h2 id="已知的限制">已知的限制</h2>
<p>GTEST被设计成线程安全的。在使用<code>pthread</code>的系统上，GTEST的实现是线程安全的，而在其他系统(如Windows)上多线程并发使用<code>Google Test</code>的断言并不安全。</p>
<p>一般情况下断言都是在主线程中进行的，因此在绝大多数测试中这并不会产生问题。</p>
<h2 id="更多的断言">更多的断言</h2>
<p>这章覆盖了一些使用频率较少但是仍然很重要的断言</p>
<h3 id="明确的成功和失败">明确的成功和失败</h3>
<p>下面三个断言没有确切的测试一个值或者表达式，而是直接生成一个成功或者失败。就像实际执行测试的宏一样，你可以将定制的失败消息传递进去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUCCEED();</span><br></pre></td></tr></table></figure>
<p>产生一个成功。这并不意味着整个测试都是成功，只有当测试的断言在执行过程中没有一个失败，测试才被认为是成功的。</p>
<p>NOTE：<code>SUCCEED()</code>纯粹是纪实的并且现阶段不产生任何用户可见的输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FAIL();</span><br><span class="line">ADD_FAILURE();</span><br><span class="line">ADD_FAILURE_AT(<span class="string">&quot;file_path&quot;</span>, line_number);</span><br></pre></td></tr></table></figure>
<p><code>FAIL()</code>产生一个致命的失败，然而<code>ADD_FAILURE()</code>和<code>ADD_FAILURE_AT()</code>产生一个非致命的错误。他们可以在控制流时决定测试的成功或者失败。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">     ... some checks ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">     ... some other checks ...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">     FAIL() &lt;&lt; <span class="string">&quot;We shouldn&#x27;t get here.&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NOTE:只能在返回值是void的函数里才能使用<code>FAIL()</code></p>
<h3 id="异常的断言">异常的断言</h3>
<p>这些用于验证一段代码是否抛出（或不抛出）给定类型的异常。</p>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 31%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_THROW(statement, exception_type);</code></td>
<td><code>EXPECT_THROW(statement, exception_type);</code></td>
<td><code>statement</code> throws an exception of the given type</td>
</tr>
<tr class="even">
<td><code>ASSERT_ANY_THROW(statement);</code></td>
<td><code>EXPECT_ANY_THROW(statement);</code></td>
<td><code>statement</code> throws an exception of any type</td>
</tr>
<tr class="odd">
<td><code>ASSERT_NO_THROW(statement);</code></td>
<td><code>EXPECT_NO_THROW(statement);</code></td>
<td><code>statement</code> doesn't throw any exception</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASSERT_THROW(Foo(<span class="number">5</span>), bar_exception);</span><br><span class="line">EXPECT_NO_THROW(&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">  Bar(&amp;n);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="为了更好地错误信息而使用谓词断言">为了更好地错误信息而使用谓词断言</h3>
<ul>
<li>尽管GTEST有一套丰富的断言，但是却永远不够，因为不可能预测用户可能遇到的所有场景。</li>
<li>有些时候缺乏更好地宏，用户只能使用<code>EXPECT_TRUE()</code>来检查复杂的表达式。但是不能向用户展示表达式各个部分的值，会让哪里出错变得难以理解。</li>
<li>作为一种变通方法，一些用户选择自己构建失败消息，将其流式传输到<code>EXPECT_TRUE()</code>中，当一个表达式有副作用或者评估起来很昂贵时，这将是十分困难的。</li>
</ul>
<p>GTEST为了解决这个问题，提出了三个选项：</p>
<h4 id="使用一个存在的布尔函数">使用一个存在的布尔函数</h4>
<p>如果已经存在一个返回bool型的函数（或者是可以隐式转换成bool），可以在谓词断言中使用它来免费打印函数的参数：</p>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 35%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_PRED1(pred1, val1)</code></td>
<td><code>EXPECT_PRED1(pred1, val1)</code></td>
<td><code>pred1(val1)</code> is true</td>
</tr>
<tr class="even">
<td><code>ASSERT_PRED2(pred2, val1, val2)</code></td>
<td><code>EXPECT_PRED2(pred2, val1, val2)</code></td>
<td><code>pred2(val1, val2)</code> is true</td>
</tr>
<tr class="odd">
<td><code>...</code></td>
<td><code>...</code></td>
<td><code>...</code></td>
</tr>
</tbody>
</table>
<ul>
<li>上述中，<code>predn</code>是一个n个参数的谓词函数，<code>val1</code>,<code>val2</code>,...,和<code>valn</code>是函数的参数。</li>
<li>当谓词应用于给定的参数时返回值为<code>true</code>，那么断言为成功，否则为失败。当断言失败时，他会打印每个参数的值。在这两种情况下，参数只被计算一次。</li>
</ul>
<p>例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if m and n have no common divisors except 1.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MutuallyPrime</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>断言如下时，将会成功：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_PRED2(MutuallyPrime, a, b);</span><br></pre></td></tr></table></figure>
<p>断言如下时，将会失败</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_PRED2(MutuallyPrime, b, c);</span><br></pre></td></tr></table></figure>
<p>失败信息如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MutuallyPrime</span>(b, c) <span class="keyword">is</span> <span class="literal">false</span>, <span class="keyword">where</span></span><br><span class="line">b <span class="keyword">is</span> <span class="number">4</span></span><br><span class="line">c <span class="keyword">is</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="使用一个返回断言结果的函数">使用一个返回断言结果的函数</h4>
<p>尽管<code>EXPECT_PRED*</code>和类似的宏对于快速工作非常方便，但是语法并不令人满意。对不不同的参数数量需要使用不同的宏，这更像Lisp而不是C++，<code>::testing::AssertionResult</code>类解决了这个问题。</p>
<p>一个<code>AssertionResult</code>对象代表了一个断言的结果（无论是成功还是失败，或是相关的信息）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> testing &#123;</span><br><span class="line"><span class="comment">// Returns an AssertionResult object to indicate that an assertion has</span></span><br><span class="line"><span class="comment">// succeeded.</span></span><br><span class="line"><span class="function">AssertionResult <span class="title">AssertionSuccess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// Returns an AssertionResult object to indicate that an assertion has</span></span><br><span class="line"><span class="comment">// failed.</span></span><br><span class="line"><span class="function">AssertionResult <span class="title">AssertionFailure</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以使用<code>&lt;&lt;</code>操作符将信息传输到<code>AssertionResult</code>对象。</p>
<p>返回值用<code>AssertionResult</code>对象代替<code>bool</code>值能够在断言中提供更多可读的信息。例如将<code>IsEven()</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">testing::AssertionResult <span class="title">IsEven</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((n % <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> ::testing::AssertionSuccess();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> ::testing::AssertionFailure() &lt;&lt; n &lt;&lt; <span class="string">&quot; is odd&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替代</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEven</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n % <span class="number">2</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，错误的断言<code>EXPECT_TRUE(IsEven(Fib(4)))</code>将会打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value of: IsEven(Fib(<span class="number">4</span>))</span><br><span class="line">  Actual: <span class="literal">false</span> (<span class="number">3</span> is odd)</span><br><span class="line">Expected: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>替代原来模糊的结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value of: IsEven(Fib(<span class="number">4</span>))</span><br><span class="line">  Actual: <span class="literal">false</span></span><br><span class="line">Expected: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="使用谓词格式器">使用谓词格式器</h4>
<p>当由<code>(ASSERT | EXPECT)_PRED_*</code>和<code>(ASSERT | EXPECT)_(TRUE | FALSE)</code>生成的默认消息不令人满意，或者谓词的某些参数不支持将数据流传输到ostream，就可以使用下面的谓词格式器来定制信息的格式。</p>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 35%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_PRED_FORMAT1(pred_format1, val1);</code></td>
<td><code>EXPECT_PRED_FORMAT1(pred_format1, val1);</code></td>
<td><code>pred_format1(val1)</code> is successful</td>
</tr>
<tr class="even">
<td><code>ASSERT_PRED_FORMAT2(pred_format2, val1, val2);</code></td>
<td><code>EXPECT_PRED_FORMAT2(pred_format2, val1, val2);</code></td>
<td><code>pred_format2(val1, val2)</code> is successful</td>
</tr>
<tr class="odd">
<td><code>...</code></td>
<td><code>...</code></td>
<td>...</td>
</tr>
</tbody>
</table>
<p>与上一组宏之间的区别在于，<code>(ASSERT | EXPECT)_PRED_FORMAT *</code>使用谓词格式化<code>(pred_formatn)</code>来代替谓词，前者是具有签名的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">testing::AssertionResult <span class="title">PredicateFormattern</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* expr1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">const</span> <span class="keyword">char</span>* expr2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">const</span> <span class="keyword">char</span>* exprn,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               T1 val1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               T2 val2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                               Tn valn)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中<code>val1</code>，<code>val2</code>，...和<code>valn</code>是谓词参数的值，而<code>expr1</code>，<code>expr2</code>，...和<code>exprn</code>是它们在源代码中出现的相应变量名。</li>
<li>类型<code>T1</code>，<code>T2</code>，...和<code>Tn</code>可以是值类型或引用类型。 例如，如果参数的类型为Foo，则可以将其声明为<code>Foo</code>或<code>const Foo＆</code>。</li>
</ul>
<p>例如，改进使用<code>EXPECT_PRED2()</code>来测试<code>MutuallyPrime()</code>中的失败消息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the smallest prime common divisor of m and n,</span></span><br><span class="line"><span class="comment">// or 1 when m and n are mutually prime.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SmallestPrimeCommonDivisor</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// A predicate-formatter for asserting that two integers are mutually prime.</span></span><br><span class="line">::<span class="function">testing::AssertionResult <span class="title">AssertMutuallyPrime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* m_expr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">const</span> <span class="keyword">char</span>* n_expr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">int</span> m,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (MutuallyPrime(m, n)) <span class="keyword">return</span> ::testing::AssertionSuccess();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> ::testing::AssertionFailure() &lt;&lt; m_expr &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; n_expr</span><br><span class="line">      &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;) are not mutually prime, &quot;</span></span><br><span class="line">      &lt;&lt; <span class="string">&quot;as they have a common divisor &quot;</span> &lt;&lt; SmallestPrimeCommonDivisor(m, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>EXPECT_PRED_FORMAT2</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EXPECT_PRED_FORMAT2</span>(<span class="type">AssertMutuallyPrime</span>, b, c);</span><br></pre></td></tr></table></figure>
<p>将会获得以下信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b and c (4 and 10) are not mutually prime, as they have a common divisor 2.</span><br></pre></td></tr></table></figure>
<p>前面介绍的许多内置断言是<code>(EXPECT | ASSERT)_PRED_FORMAT *</code>的特殊情况。 实际上，大多数确实是使用<code>(EXPECT | ASSERT)_PRED_FORMAT *</code>定义的。</p>
<h3 id="浮点数比较">浮点数比较</h3>
<ul>
<li>比较浮点数很棘手。由于舍入误差，两个浮点将很难完全匹配。因此<code>ASSERT_EQ</code>的比较通常不起作用。</li>
<li>由于浮点具有十分广泛的取值范围，没有单个固定的错误界限能够一直有效。</li>
<li>最好以固定的相对误差范围进行比较，除了那些接近0的值，因为浮点数在0附近会丢失精度。</li>
<li>通常，为了使浮点的比较有意义，用户需要仔细选择误差范围。如果他们不希望或不在乎，则比较“最后一位”（Units in Last Place）是一个很好的默认值，并且googletest提供了断言来做到这一点。</li>
</ul>
<h4 id="浮点宏">浮点宏</h4>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 30%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_FLOAT_EQ(val1, val2);</code></td>
<td><code>EXPECT_FLOAT_EQ(val1, val2);</code></td>
<td>the two <code>float</code> values are almost equal</td>
</tr>
<tr class="even">
<td><code>ASSERT_DOUBLE_EQ(val1, val2);</code></td>
<td><code>EXPECT_DOUBLE_EQ(val1, val2);</code></td>
<td>the two <code>double</code> values are almost equal</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“几乎相等”是指这些值彼此之间在4个ULP之内。</p>
</blockquote>
<p>以下断言允许选择可接受的错误范围：</p>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 27%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_NEAR(val1, val2, abs_error);</code></td>
<td><code>EXPECT_NEAR(val1, val2, abs_error);</code></td>
<td>the difference between <code>val1</code> and <code>val2</code> doesn't exceed the given absolute error</td>
</tr>
</tbody>
</table>
<h4 id="浮点类型谓词格式函数">浮点类型谓词格式函数</h4>
<p>一些浮点运算很有用，但并不常用。为了避免出现新的宏，我们将它们作为谓语格式函数提供，可在谓词断言宏中使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_PRED_FORMAT2(::testing::FloatLE, val1, val2);</span><br><span class="line">EXPECT_PRED_FORMAT2(::testing::DoubleLE, val1, val2);</span><br></pre></td></tr></table></figure>
<p>验证<code>val1</code>是否小于等于<code>val2</code>。也可以将上表中的<code>EXPECT_PRED_FORMAT2</code>替换为<code>ASSERT_PRED_FORMAT2</code>。</p>
<h3 id="使用gmock匹配器进行断言">使用gMock匹配器进行断言</h3>
<p>gMock带有一个匹配器库，用于验证传递给模拟对象的参数。gMock匹配器是知道如何描述自己的基本谓词。可以在这些断言宏中使用gMock匹配器。</p>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 37%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_THAT(value, matcher);</code></td>
<td><code>EXPECT_THAT(value, matcher);</code></td>
<td>value matches matcher</td>
</tr>
</tbody>
</table>
<p>例如，<code>StartsWith(prefix)</code>是一个匹配器，它匹配以<code>prefix</code>开头的字符串，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ::testing::StartsWith;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Verifies that Foo() returns a string starting with &quot;Hello&quot;.</span></span><br><span class="line">    EXPECT_THAT(Foo(), StartsWith(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>gMock具有丰富的匹配器集。 您可以做很多googletest无法独自完成的事情。</p>
<p>gMock与googletest捆绑在一起，因此无需添加任何构建依赖项即可利用此优势。只需添加<code>“ testing / base / public / gmock.h”</code>，就可以开始使用。</p>
<h3 id="更多的字符串断言">更多的字符串断言</h3>
<p>您可以使用带有<code>EXPECT THAT()</code>或<code>ASSERT THAT()</code>的gMock字符串匹配器来执行更多的字符串比较技巧(子字符串、前缀、后缀、正则表达式等)。例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ::testing::HasSubstr;</span><br><span class="line"><span class="keyword">using</span> ::testing::MatchesRegex;</span><br><span class="line">...</span><br><span class="line">  ASSERT_THAT(foo_string, HasSubstr(<span class="string">&quot;needle&quot;</span>));</span><br><span class="line">  EXPECT_THAT(bar_string, MatchesRegex(<span class="string">&quot;\\w*\\d+&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>如果该字符串包含格式正确的HTML或XML文档，则可以检查其DOM树是否与XPath表达式匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Currently still in //template/prototemplate/testing:xpath_matcher</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;template/prototemplate/testing/xpath_matcher.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> prototemplate::testing::MatchesXPath;</span><br><span class="line">EXPECT_THAT(html_string, MatchesXPath(<span class="string">&quot;//a[text()=&#x27;click here&#x27;]&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="windows-hresult断言">Windows HRESULT断言</h3>
<p>这些断言测试<code>HRESULT</code>成功或者失败</p>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 34%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_HRESULT_SUCCEEDED(expression)</code></td>
<td><code>EXPECT_HRESULT_SUCCEEDED(expression)</code></td>
<td><code>expression</code> is a success <code>HRESULT</code></td>
</tr>
<tr class="even">
<td><code>ASSERT_HRESULT_FAILED(expression)</code></td>
<td><code>EXPECT_HRESULT_FAILED(expression)</code></td>
<td><code>expression</code> is a failure <code>HRESULT</code></td>
</tr>
</tbody>
</table>
<p>生成的输出包含与表达式返回的HRESULT代码相关的可读错误消息。</p>
<p>例如可以这样使用：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CComPtr&lt;IShellDispatch2&gt; shell;</span><br><span class="line">ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L<span class="string">&quot;Shell.Application&quot;</span>));</span><br><span class="line">CComVariant <span class="keyword">empty</span>;</span><br><span class="line">ASSERT_HRESULT_SUCCEEDED(shell-&gt;ShellExecute(CComBSTR(url), <span class="keyword">empty</span>, <span class="keyword">empty</span>, <span class="keyword">empty</span>, <span class="keyword">empty</span>));</span><br></pre></td></tr></table></figure>
<h3 id="类型断言">类型断言</h3>
<p>可以调用以下函数：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:</span><span class="symbol">:testing</span><span class="symbol">:</span><span class="symbol">:StaticAssertTypeEq&lt;T1</span>, T2&gt;();</span><br></pre></td></tr></table></figure>
<p>来判断<code>T1</code>和<code>T2</code>的值是否相同。如果断言得到满足，该函数将不执行任何操作。如果类型不同，则函数调用将编译失败，编译器错误消息将指出T1和T2不是同一类型，并且很可能（取决于编译器）显示<code>T1</code>和<code>T2</code>的实际值。 这主要使用在模板代码中。</p>
<p><strong>警告</strong>：在类模板或函数模板的成员函数中使用时，<code>StaticAssertTypeEq &lt;T1，T2&gt;（）</code>仅在实例化函数时才有效。 例如，给定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123; ::testing::StaticAssertTypeEq&lt;<span class="keyword">int</span>, T&gt;(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span> </span>&#123; Foo&lt;<span class="keyword">bool</span>&gt; foo; &#125;</span><br></pre></td></tr></table></figure>
<p>不会导致编译错误，因为<code>Foo&lt;bool&gt;::Bar()</code>没有被实例化。相反，以下代码会导致编译错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Foo&lt;<span class="keyword">bool</span>&gt; foo; </span><br><span class="line">    foo.Bar();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="断言的位置">断言的位置</h3>
<ul>
<li>可以在任何C ++函数中使用断言，它不一定是测试类中的的方法。但是有一个约束，生成致命故障的断言<code>(FAIL*和ASSERT_ *)</code>只能在返回void的函数中使用。</li>
<li>如果将其放在返回值费控的函数中，将得到一个令人困惑的编译错误，例如：<code>"error: void value not ignored as it ought to be"</code>或者<code>"cannot initialize return object of type 'bool' with an rvalue of type 'void'"</code>或者<code>"error: no viable conversion from 'void' to 'string'"</code>。</li>
<li>如果需要在一个返回值不是void的函数中使用致命断言，可以让函数在参数中返回需要返回的值。例如，将函数<code>T2 Foo(T1 x)</code>重写成<code>void Foo(T1 x, T2* result)</code>。</li>
<li>这需要确保<code>* result</code>包含一些合理的值，即使函数过早的返回也需要确保。由于函数现在返回void，因此可以在其中使用任何断言。</li>
<li>如果不能选择更改函数的类型，则应仅使用会产生非致命故障的断言，例如<code>ADD_FAILURE *</code>和<code>EXPECT_ *</code>。</li>
</ul>
<p><strong>注意</strong>:根据c++语言规范，构造函数和析构函数不被认为是返回值为void的函数，因此不能在它们中使用致命的断言;如果尝试，将得到编译错误。相反，要么调用<code>abort</code>并崩溃整个测试可执行文件，要么将致命的断言放在<code>SetUp/TearDown</code>函数中;</p>
<p><strong>警告</strong>:当构造函数或析构函数调用一个包含致命断言的helper函数(私有的void-returning方法)时，不会终止当前的测试。它仅仅会过早地从构造函数或析构函数中返回，并且可能让对象处在在一个部分构造或部分析构的状态。所以应该使用<code>abort</code>或者<code>SetUp/TearDown</code>函数代替它。</p>
<h2 id="教gtest如何打印你的值">教GTEST如何打印你的值</h2>
<ul>
<li>当测试断言(例如<code>EXPECT_EQ</code>)失败时，googletest会输出参数值以帮助进行调试。它使用用户可扩展值打印器执行此操作。</li>
<li>该打印器知道如何打印内置的C++类型、原生数组、STL容器以及任何支持<code>&lt;&lt;</code>操作符的类型。对于其他类型，它将在值中打印原始字节，并希望用户可以理解它。</li>
</ul>
<p>如前所述，打印器是可扩展的。这意味着可以教它在打印特定类型方面做的更好，而不是仅打印转储字节。为此，需要为你定义的类型定义<code>&lt;&lt;</code>操作符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span>  <span class="comment">// We want googletest to be able to print instances of this.</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Create a free inline friend function.</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> Bar&amp; bar) &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; bar.DebugString();  <span class="comment">// whatever needed to print bar to os</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you can&#x27;t declare the function in the class it&#x27;s important that the</span></span><br><span class="line"><span class="comment">// &lt;&lt; operator is defined in the SAME namespace that defines Bar.  C++&#x27;s look-up</span></span><br><span class="line"><span class="comment">// rules rely on that.</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> Bar&amp; bar) &#123;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; bar.DebugString();  <span class="comment">// whatever needed to print bar to os</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace foo</span></span><br></pre></td></tr></table></figure>
<p>有时团队可能会认为为<code>Bar</code>设置<code>&lt;&lt;</code>操作符可能是不好的风格，或者<code>Bar</code>可能已经具有<code>&lt;&lt;</code>操作符但没有做想要的事情（并且无法更改它）。如果是这样，可以改为定义一个<code>PrintTo()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">PrintTo</span><span class="params">(<span class="keyword">const</span> Bar&amp; bar, <span class="built_in">std</span>::ostream* os)</span> </span>&#123;</span><br><span class="line">    *os &lt;&lt; bar.DebugString();  <span class="comment">// whatever needed to print bar to os</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you can&#x27;t declare the function in the class it&#x27;s important that PrintTo()</span></span><br><span class="line"><span class="comment">// is defined in the SAME namespace that defines Bar.  C++&#x27;s look-up rules rely</span></span><br><span class="line"><span class="comment">// on that.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTo</span><span class="params">(<span class="keyword">const</span> Bar&amp; bar, <span class="built_in">std</span>::ostream* os)</span> </span>&#123;</span><br><span class="line">  *os &lt;&lt; bar.DebugString();  <span class="comment">// whatever needed to print bar to os</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace foo</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果同时定义了<code>&lt;&lt;</code>和<code>PrintTo()</code>，则在使用googletest时将使用后者。这样就可以自定义待打印值在googletest输出中的显示方式，而不会影响依赖于<code>&lt;&lt;</code>操作符的行为的代码。</p>
</blockquote>
<p>如果您想使用googletest的值打印器自己打印值<code>x</code>，只需调用<code>::testing::PrintToString(x)</code>，它会返回一个<code>std::string</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;Bar, <span class="keyword">int</span>&gt; &gt; bar_ints = GetBarIntVector();</span><br><span class="line">EXPECT_TRUE(IsCorrectBarIntVector(bar_ints))</span><br><span class="line">    &lt;&lt; <span class="string">&quot;bar_ints = &quot;</span> &lt;&lt; ::testing::PrintToString(bar_ints);</span><br></pre></td></tr></table></figure>
<h2 id="死亡测试">死亡测试</h2>
<ul>
<li>在许多应用程序中，有一些断言会在不满足条件的情况下导致应用程序失败。</li>
<li>这些健全性检查可确保程序处于已知的良好状态，并在某些程序状态损坏后的最早可能的时间点失败。</li>
<li>如果断言检查了错误的条件，则程序可能会以错误的状态运行，这可能导致内存损坏，安全漏洞或更糟。因此，测试此类断言语句是否按预期工作至关重要。</li>
<li>由于这些前提条件检查会导致进程终止，因此我们将此类测试称为死亡测试。 更一般而言，任何以预期方式检查程序是否终止（除非引发异常）的测试也都是死亡测试。</li>
<li>请注意，如果一段代码抛出异常，则出于死亡测试的目的，我们不会将其视为“死亡”，因为代码的调用者可以捕获该异常并避免崩溃。 如果要验证代码引发的异常，请参见异常断言。</li>
</ul>
<h3 id="如何编写死亡测试">如何编写死亡测试</h3>
<p>GTEST提供以下的宏来进行死亡测试</p>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 30%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_DEATH(statement, matcher);</code></td>
<td><code>EXPECT_DEATH(statement, matcher);</code></td>
<td><code>statement</code> crashes with the given error</td>
</tr>
<tr class="even">
<td><code>ASSERT_DEATH_IF_SUPPORTED(statement, matcher);</code></td>
<td><code>EXPECT_DEATH_IF_SUPPORTED(statement, matcher);</code></td>
<td>if death tests are supported, verifies that <code>statement</code> crashes with the given error; otherwise verifies nothing</td>
</tr>
<tr class="odd">
<td><code>ASSERT_DEBUG_DEATH(statement, matcher);</code></td>
<td><code>EXPECT_DEBUG_DEATH(statement, matcher);</code></td>
<td><code>statement</code> crashes with the given error <strong>in debug mode</strong>. When not in debug (i.e. <code>NDEBUG</code> is defined), this just executes <code>statement</code></td>
</tr>
<tr class="even">
<td><code>ASSERT_EXIT(statement, predicate, matcher);</code></td>
<td><code>EXPECT_EXIT(statement, predicate, matcher);</code></td>
<td><code>statement</code> exits with the given error, and its exit code matches <code>predicate</code></td>
</tr>
</tbody>
</table>
<p>其中，<code>statement</code>是预期会导致进程终止的语句，<code>predicate</code>是评估整数退出状态的函数或函数对象，<code>matcher</code>是与<code>const std :: string＆</code>匹配的<code>gMock marcher</code>或（Perl）正则表达式 ，两者都与<code>statement</code>的<code>stderr</code>输出匹配。由于遗留原因，裸字符串（即没有匹配器）被解释为<code>ContainsRegex(str)</code>，而不是<code>Eq(str)</code>。 请注意，<code>statement</code>可以是任何有效的语句（包括复合语句），而不必是表达式。</p>
<blockquote>
<p>注意：在宏的描述中使用崩溃(crash)代表进程是以一个非零的状态码终结的。这有两种可能：一是进程调用了非零值得<code>exit()</code>或者<code>_exit()</code>，二是被一个信号量杀死了。 这表明了如果<code>statement</code>终结了一个进程并返回0，<code>EXPECT_DEATH()</code>不认为这是一个崩溃。在这种情况下应该使用<code>EXPECT_EXIT</code>代替，或者更精确地限制退出代码。</p>
</blockquote>
<p>这里的谓词(predicate)必须接受一个<code>int</code>返回一个<code>bool</code>。仅仅当谓词返回<code>true</code>时，代表死亡测试成功。GTEST定义了一些谓词能够处理大部分的情况：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::testing</span><span class="selector-pseudo">::ExitedWithCode(exit_code)</span></span><br></pre></td></tr></table></figure>
<p>如果程序使用给定的退出码正常退出，那么将返回<code>true</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::testing::KilledBySignal(signal_number)  <span class="comment">// Not available on Windows.</span></span><br></pre></td></tr></table></figure>
<p>如果程序被给定的信号量杀死，就会返回<code>true</code></p>
<p><code>* _DEATH</code>宏是<code>* _EXIT</code>的便捷包装器，它们使用谓词来验证进程的退出代码是否为非零。</p>
<p>注意一个死亡测试只关注三件事：</p>
<ol type="1">
<li><code>statement</code>有没有终止或者退出进程</li>
<li>对于<code>ASSERT_EXIT</code>和<code>EXPECT_EXIT</code>退出状态是否满足谓词？ 或者在<code>ASSERT_DEATH</code>和<code>EXPECT_DEATH</code>的情况下退出状态是否为非零</li>
<li><code>stderr</code>的输出是否符合<code>marcher</code></li>
</ol>
<p>特别是，如果语句生成<code>ASSERT_ *</code>或<code>EXPECT_ *</code>错误，则不会导致死亡测试失败，因为googletest断言不会终止该进程。</p>
<p>死亡测试的例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TEST(MyDeathTest, Foo) &#123;</span><br><span class="line">  <span class="comment">// This death test uses a compound statement.</span></span><br><span class="line">  ASSERT_DEATH(&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    Foo(&amp;n);</span><br><span class="line">  &#125;, <span class="string">&quot;Error on line .* of Foo()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(MyDeathTest, NormalExit) &#123;</span><br><span class="line">  EXPECT_EXIT(NormalExit(), ::testing::ExitedWithCode(<span class="number">0</span>), <span class="string">&quot;Success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(MyDeathTest, KillMyself) &#123;</span><br><span class="line">  EXPECT_EXIT(KillMyself(), ::testing::KilledBySignal(SIGKILL),</span><br><span class="line">              <span class="string">&quot;Sending myself unblockable signal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些测试验证了：</p>
<ul>
<li>调用<code>Foo(5)</code>导致进程使用给定的错误信息结束</li>
<li>调用<code>NormalExit()</code>导致进程在<code>stderr</code>上打印<code>Success</code>并且退出码为0</li>
<li>调用<code>KillMyself()</code>会用信号量<code>SIGKILL</code>杀死进程</li>
</ul>
<h3 id="死亡测试命名">死亡测试命名</h3>
<ul>
<li>重要说明：当测试包含死亡测试时，如上面的示例所示。强烈建议遵循命名<strong>test suite</strong>（而非测试）加<code>* DeathTest</code>的约定， 下面的“死亡测试和线程”部分解释了原因。</li>
<li>如果一个test fixture类被普通测试和死亡测试所共享，可以使用using或typedef为Fixture类引入别名，并避免重复其代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> FooDeathTest = FooTest;</span><br><span class="line"></span><br><span class="line">TEST_F(FooTest, DoesThis) &#123;</span><br><span class="line">  <span class="comment">// normal test</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST_F(FooDeathTest, DoesThat) &#123;</span><br><span class="line">  <span class="comment">// death test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死亡测试如何工作的">死亡测试如何工作的</h3>
<p>在后台，<code>ASSERT_EXIT()</code>产生一个新进程并在该进程中执行死亡测试语句。具体发生情况的详细信息取决于平台和变量<code>::testing::GTEST_FLAG(death_test_style)</code>。</p>
<ul>
<li><p>在POSIX系统上，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fork()</span><br></pre></td></tr></table></figure>
<p>(或Linux上的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone()</span><br></pre></td></tr></table></figure>
<p>）来生成子子进程，然后</p>
<ul>
<li>如果变量的值为<code>“ fast”</code>，则将立即执行死亡测试语句。</li>
<li>如果变量的值是<code>“threadsafe”</code>，则子进程将像第一次调用一样重新执行单元测试二进制文件，但是会带有一些额外的标志导致只运行这一个死亡测试</li>
</ul></li>
<li><p>在Windows上，使用<code>CreateProcess（）</code>API生成子对象，然后重新执行二进制文件并且仅运行该单个死亡测试-就像POSIX上的线程安全模式一样。</p></li>
</ul>
<p>变量的其他值是非法的，将导致死亡测试失败。 当前，该标志的默认值为<code>“fast”</code></p>
<ol type="1">
<li>子进程的退出码符合谓词</li>
<li>子进程的stderr输出符合正则表达式</li>
</ol>
<p>如果死亡测试语句运行到完成而没有死亡，则子进程将终止，并且断言失败。</p>
<h3 id="死亡测试和线程">死亡测试和线程</h3>
<p>有两种死亡测试类型的原因与线程安全性有关。由于fork线程时存在的众所周知的问题，死亡测试应该在单线程上下文中运行。但是，有时布置这样的环境是不可行的。例如，静态初始化的模块可能在到达main之前启动线程。线程一旦创建后，可能很难或无法清理它们。</p>
<p>googletest具有三个功能，旨在提高人们对线程问题的认识：</p>
<ol type="1">
<li>运行死亡测试时，如果有多个线程正在运行，则会发出警告。</li>
<li>名称以<code>“ DeathTest”</code>结尾的Test suites将在所有其他测试之前运行。</li>
<li>使用<code>clone()</code>而不是<code>fork()</code>来在Linux上生成子进程（在Cygwin和Mac上不支持<code>clone()</code>），因为在父进程具有多个线程时，<code>fork()</code>更有可能导致子进程挂起。</li>
</ol>
<p>在死亡测试语句中创建线程是完全可行的。它们在单独的进程中执行，不会影响父进程。</p>
<h3 id="死亡测试类型">死亡测试类型</h3>
<p>引入了“线程安全”死亡测试类型，以帮助减轻可能在多线程环境中进行测试的风险。它以增加测试执行时间（可能会如此）为代价，以提高线程安全性。</p>
<p>自动测试框架未设置样式标志。可以通过设置标志来选择一种特定的死亡测试类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testing::FLAGS_gtest_death_test_style=<span class="string">&quot;threadsafe&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以在<code>main()</code>中执行此操作，以设置二进制文件或单个测试中所有死亡测试的样式。 在每个测试前会保存标志并在运行完成后恢复它，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  InitGoogle(argv[<span class="number">0</span>], &amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">  ::testing::FLAGS_gtest_death_test_style = <span class="string">&quot;fast&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(MyDeathTest, TestOne) &#123;</span><br><span class="line">  ::testing::FLAGS_gtest_death_test_style = <span class="string">&quot;threadsafe&quot;</span>;</span><br><span class="line">  <span class="comment">// This test is run in the &quot;threadsafe&quot; style:</span></span><br><span class="line">  ASSERT_DEATH(ThisShouldDie(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(MyDeathTest, TestTwo) &#123;</span><br><span class="line">  <span class="comment">// This test is run in the &quot;fast&quot; style:</span></span><br><span class="line">  ASSERT_DEATH(ThisShouldDie(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="警告">警告</h3>
<p><code>ASSERT_EXIT()</code>的<code>statement</code>参数可以是任何有效的C++语句。如果它通过return语句或引发异常离开当前函数，则将死亡测试视为失败。某些googletest宏可能会从当前函数中返回（例如<code>ASSERT_TRUE()</code>），因此请确保在<code>statement</code>中避免使用它们。</p>
<p>由于<code>statement</code>在子进程中运行，因此它引起的任何内存中副作用（例如，修改变量，释放内存等）在父进程中都是无法观察到的。特别是，如果在死亡测试中释放内存，则程序将无法通过堆检查，因为父进程将永远不会看到回收的内存。 为了解决这个问题，可以:</p>
<ol type="1">
<li>在死亡测试中不释放内存</li>
<li>在父进程中再释放一遍内存</li>
<li>在程序中不实用堆检查</li>
</ol>
<p>由于实现细节，不能在同一行上放置多个死亡测试断言，否则编译将失败，并显示明显的错误消息。</p>
<p>尽管“线程安全”类型的死亡测试提供了提高的线程安全性，但是在向<code>pthread_atfork(3)</code>注册的处理程序存在的情况下，诸如死锁之类的线程问题仍然可能出现。</p>
<h2 id="在子例程中使用断言">在子例程中使用断言</h2>
<h3 id="向断言添加跟踪">向断言添加跟踪</h3>
<p>如果从多个地方调用了一个测试子例程，则当其中的一个断言失败时，很难确定该失败来自哪个子例程调用。可以使用额外的日志记录或自定义失败消息来缓解此问题，但这通常会使测试混乱。更好的解决方案是使用<code>SCOPED_TRACE</code>宏或<code>ScopedTrace</code>工具：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCOPED_TRACE(message);</span><br><span class="line"><span class="function">ScopedTrace <span class="title">trace</span><span class="params">(<span class="string">&quot;file_path&quot;</span>, line_number, message)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>message</code>可以是可流式传输到<code>std::ostream</code>的任何内容。<code>SCOPED_TRACE</code>宏将使当前文件名，行号和给定的消息被添加到每个失败消息中。<code>ScopedTrace</code>在参数中接受显式的文件名和行号，这对于编写测试非常有用。当控件离开当前词法范围时，效果将被撤消。 例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sub1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  EXPECT_EQ(Bar(n), <span class="number">1</span>);</span><br><span class="line">  EXPECT_EQ(Bar(n + <span class="number">1</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">TEST(FooTest, Bar) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">     SCOPED_TRACE(<span class="string">&quot;A&quot;</span>);  <span class="comment">// This trace point will be included in</span></span><br><span class="line">                                      <span class="comment">// every failure in this scope.</span></span><br><span class="line">     Sub1(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Now it won&#x27;t.</span></span><br><span class="line">   Sub1(<span class="number">9</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>结果信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">path&#x2F;to&#x2F;foo_test.cc:11: Failure</span><br><span class="line">Value of: Bar(n)</span><br><span class="line">Expected: 1</span><br><span class="line">  Actual: 2</span><br><span class="line">Google Test trace:</span><br><span class="line">path&#x2F;to&#x2F;foo_test.cc:17: A</span><br><span class="line"></span><br><span class="line">path&#x2F;to&#x2F;foo_test.cc:12: Failure</span><br><span class="line">Value of: Bar(n + 1)</span><br><span class="line">Expected: 2</span><br><span class="line">  Actual: 3</span><br></pre></td></tr></table></figure>
<p>如果没有跟踪，将很难知道这两个失败分别来自<code>Sub1()</code>的调用。</p>
<p>使用<code>SCOPED_TRACE</code>的一些技巧：</p>
<ol type="1">
<li>使用适当的<code>message</code>，并且在子例程的开头而不是在每个调用的地方使用<code>SCOPED_TRACE</code>。</li>
<li>在循环内调用子例程时，请在<code>SCOPED_TRACE</code>中将循环迭代器作为消息的一部分，以便您可以知道失败来自哪个迭代。</li>
<li>有时跟踪点的行号足以标识子例程的特定调用。在这种情况下，不必为<code>SCOPED_TRACE</code>选择唯一的消息，可以简单地使用“”。</li>
<li>如果外部作用域中已经有了一个<code>SCOPED_TRACE</code>，则可以在内部作用域中继续使用<code>SCOPED_TRACE</code>。 在这种情况下，所有活动的跟踪点都将以遇到宏的相反顺序包含在故障消息中。</li>
<li>跟踪转储可以在Emacs中选中行号并<code>return</code>，就会跳转到源文件中的该行</li>
</ol>
<h3 id="传递致命错误">传递致命错误</h3>
<p>使用<code>ASSERT_ *</code>和<code>FAIL *</code>有一个难以理解的常见陷阱，即当它们失败时只会中止当前功能，而不是整个测试。 例如，以下测试将发生段错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Subroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Generates a fatal failure and aborts the current function.</span></span><br><span class="line">  ASSERT_EQ(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following won&#x27;t be executed.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(FooTest, Bar) &#123;</span><br><span class="line">  Subroutine();  <span class="comment">// The intended behavior is for the fatal failure</span></span><br><span class="line">                 <span class="comment">// in Subroutine() to abort the entire test.</span></span><br><span class="line">  <span class="comment">// The actual behavior: the function goes on after Subroutine() returns.</span></span><br><span class="line">  <span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">  *p = <span class="number">3</span>;  <span class="comment">// Segfault!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了缓解这种情况，googletest提供了三种不同的解决方案。即抛出异常、<code>(ASSERT | EXPECT)_NO_FATAL_FAILURE</code>断言和<code>HasFatalFailure()</code>函数。 在以下两个小节中将对它们进行了描述。</p>
<p><strong>使用一个带有异常处理的断言</strong></p>
<p>以下代码可以将ASSERT-failure变成异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThrowListener</span> :</span> <span class="keyword">public</span> testing::EmptyTestEventListener &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnTestPartResult</span><span class="params">(<span class="keyword">const</span> testing::TestPartResult&amp; result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.type() == testing::TestPartResult::kFatalFailure) &#123;</span><br><span class="line">      <span class="keyword">throw</span> testing::AssertionException(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  testing::UnitTest::GetInstance()-&gt;listeners().Append(<span class="keyword">new</span> ThrowListener);</span><br><span class="line">  <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有其他侦听器，则应在其他侦听器之后添加此侦听器，否则它们将看不到失败的<code>OnTestPartResult</code>。</p>
<p><strong>在子例程中断言</strong></p>
<p>如上所示，如果您的测试调用了一个其中有<code>ASSERT_ *</code>失败的子例程，则该子例程返回后，测试将继续。人们通常希望致命的失败像异常一样传播。为此，googletest提供了以下宏</p>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 27%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ASSERT_NO_FATAL_FAILURE(statement);</code></td>
<td><code>EXPECT_NO_FATAL_FAILURE(statement);</code></td>
<td><code>statement</code> doesn't generate any new fatal failures in the current thread.</td>
</tr>
</tbody>
</table>
<p>该宏仅仅检查执行断言的线程中的故障，来确定此类断言的结果。如果<code>statement</code>创建了新线程，那么这些线程中的故障将被忽略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ASSERT_NO_FATAL_FAILURE(Foo());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">EXPECT_NO_FATAL_FAILURE(&#123;</span><br><span class="line">  i = Bar();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Windows当前不支持来自多个线程的断言</p>
<p><strong>在当前测试中检测失败</strong></p>
<p>如果当前测试中的断言遭受致命故障,<code>::testing::Test</code>类中的<code>HasFatalFailure()</code>将返回true。这使函数可以在子例程中捕获致命故障并尽早返回。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Test</span> &#123;</span><br><span class="line"> <span class="attribute">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  static bool <span class="built_in">HasFatalFailure</span>();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>典型的用法是模拟一个抛出异常的操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEST(FooTest, Bar) &#123;</span><br><span class="line">  Subroutine();</span><br><span class="line">  <span class="comment">// Aborts if Subroutine() had a fatal failure.</span></span><br><span class="line">  <span class="keyword">if</span> (HasFatalFailure()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// The following won&#x27;t be executed.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在<code>TEST()</code>，<code>TEST_F()</code>或<code>test fixture</code>之外使用<code>HasFatalFailure()</code>，则必须添加<code>::testing::Test::</code>前缀，如下所示：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (::testing::Test::HasFatalFailure()) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>类似的，如果当前测试至少有一个非致命故障，则<code>HasNonfatalFailure()</code>返回<code>true</code>，如果当前测试有两种失败中的任意一个，则<code>HasFailure()</code>返回<code>true</code>。</p>
<h2 id="记录额外的信息">记录额外的信息</h2>
<p>在测试代码中，您可以调用<code>RecordProperty（"key"，value）</code>记录额外的信息，其中<code>value</code>可以是字符串或<code>int</code>。 <code>key</code>记录的最后一个值将被发送到指定的XML输出。 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEST_F(WidgetUsageTest, MinAndMaxWidgets) &#123;</span><br><span class="line">  RecordProperty(<span class="string">&quot;MaximumWidgets&quot;</span>, ComputeMaxUsage());</span><br><span class="line">  RecordProperty(<span class="string">&quot;MinimumWidgets&quot;</span>, ComputeMinUsage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将会输出XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="tag">&lt;<span class="name">testcase</span> <span class="attr">name</span>=<span class="string">&quot;MinAndMaxWidgets&quot;</span> <span class="attr">status</span>=<span class="string">&quot;run&quot;</span> <span class="attr">time</span>=<span class="string">&quot;0.006&quot;</span> <span class="attr">classname</span>=<span class="string">&quot;WidgetUsageTest&quot;</span> <span class="attr">MaximumWidgets</span>=<span class="string">&quot;12&quot;</span> <span class="attr">MinimumWidgets</span>=<span class="string">&quot;9&quot;</span> /&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
</blockquote>
<blockquote>
<ul>
<li><code>RecordProperty()</code>是<code>Test</code>类的静态成员。 因此，如果在<code>TEST</code>主体和测试夹具类的外部使用，则必须以<code>::testing::Test::</code>作为前缀。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>key</code>必须是合法的XML属性名称，并且不能和GTEST已有的属性相冲突(<code>name</code>, <code>status</code>, <code>time</code>, <code>classname</code>, <code>type_param</code>, and <code>value_param</code>)。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>允许在测试的生命周期之外调用<code>RecordProperty（）</code>。 如果在测试外部调用它，但在测试套件的<code>SetUpTestSuite（）</code>和<code>TearDownTestSuite（）</code>方法之间调用，它将被归因于该测试套件的XML元素。 如果在所有测试套件之外（例如在测试环境中）调用它，则它将归因于顶级XML元素。</li>
</ul>
</blockquote>
<h2 id="在相同测试套件中的不同测试之间共享资源">在相同测试套件中的不同测试之间共享资源</h2>
<p>googletest为每个测试创建一个新的test fixture对象，使测试独立且易于调试。然而，有时测试使用的资源昂贵，因此“每个测试一份拷贝”模型的成本过高。</p>
<p>如果测试不更改资源，那么共享单个资源副本不会有任何危害。 因此，除了按测试设置<code>Setup/TearDown</code>外，googletest还支持按testsuit设置<code>SetUp/TearDown</code>。 要使用它：</p>
<ol type="1">
<li>在<code>test fixture</code>类（例如FooTest）中，将一些成员变量声明为<strong>静态变量</strong>以保存共享资源。</li>
<li>在<code>test fixture</code>类之外（通常在它的下面），定义那些成员变量，可以选择性的初始化它们。</li>
<li>在同一<code>test fixture</code>类中，定义一个静态的<code>void SetUpTestSuite（）</code>函数（请记住不要将它拼写为带有小u的<code>SetupTestCase</code>）来配置共享资源，并定义一个静态的<code>TearDownTestCase（）</code>函数来清理共享资源。</li>
</ol>
<p>GTEST在运行<code>FooTest</code>中第一个测试之前调用<code>SetUpCase</code>(在创建第一个<code>FooTest</code>对象前)，并且在最后一个测试之后（删除最后一个<code>FooTest</code>对象之后）调用<code>TearDownCase()</code>。在中间，所有的测试使用共享的资源。</p>
<p>请记住，测试顺序是不确定的，因此代码不能依赖于另一个测试。 同样，测试必须不能修改任何共享资源的状态。如果确实要修改状态，则必须在将控制权传递给下一个测试之前将状态恢复为原始值。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// Per-test-suite set-up.</span></span><br><span class="line">  <span class="comment">// Called before the first test in this test suite.</span></span><br><span class="line">  <span class="comment">// Can be omitted if not needed.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetUpTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_resource_ = <span class="keyword">new</span> ...;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Per-test-suite tear-down.</span></span><br><span class="line">  <span class="comment">// Called after the last test in this test suite.</span></span><br><span class="line">  <span class="comment">// Can be omitted if not needed.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TearDownTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> shared_resource_;</span><br><span class="line">    shared_resource_ = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// You can define per-test set-up logic as usual.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">// You can define per-test tear-down logic as usual.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">// Some expensive resource shared by all tests.</span></span><br><span class="line">  <span class="keyword">static</span> T* shared_resource_;</span><br><span class="line">&#125;;</span><br><span class="line">T* FooTest::shared_resource_ = <span class="literal">NULL</span>;</span><br><span class="line">TEST_F(FooTest, Test1) &#123;</span><br><span class="line">  ... you can refer to shared_resource_ here ...</span><br><span class="line">&#125;</span><br><span class="line">TEST_F(FooTest, Test2) &#123;</span><br><span class="line">  ... you can refer to shared_resource_ here ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：尽管上面的代码声明<code>SetUpTestSuite（）</code>为<code>protect</code>，但有时可能需要将其声明为<code>public</code>，例如与<code>TEST_P</code>一起使用时。</p>
<h2 id="全局setup和teardown">全局SetUp和TearDown</h2>
<p><code>setup</code>和<code>teardown</code>可以在测试层面，测试套件级别上进行，同样也可以在程序级别上进行。</p>
<p>首先，定义一个知道如何<code>setup</code>和<code>teardown</code>的<code>::test::Environment</code>的子类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Environment</span> : <span class="title">public</span> ::<span class="title">testing</span>::<span class="title">Environment</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~Environment() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// Override this to define how to set up the environment.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetUp</span>(<span class="params"></span>) <span class="keyword">override</span></span> &#123;&#125;</span><br><span class="line">  <span class="comment">// Override this to define how to tear down the environment.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">TearDown</span>(<span class="params"></span>) <span class="keyword">override</span></span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来调用<code>::testing::AddGlobalTestEnvironment()</code>函数在GTEST中注册一个Environment的实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Environment* <span class="title">AddGlobalTestEnvironment</span><span class="params">(Environment* env)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当调用<code>RUN_ALL_TESTS()</code>时，首先调用每个environment的<code>SetUp()</code>函数，接下来如果环境报告没有报错且未调用<code>GTEST_SKIP()</code>，则继续运行测试。<code>RUN_ALL_TEST()</code>总是会调用每个environment对象的<code>TearDown()</code>函数，无论测试有没有运行。</p>
<p>注册多个environment对象是可行的，在此套件中，按他们注册的顺序调用它们的<code>SetUp()</code>，并按相反的顺序调用他们的<code>TearDown()</code>。</p>
<p>注意GTEST拥有已注册环境对象的所有权。 因此<strong>请勿自行删除它们</strong>。</p>
<p>一般在<code>main()</code>函数中调用<code>RUN_ALL_TEST()</code>之前需要先调用<code>AddGlobalTestEnvironment()</code>。但是如果使用了<code>gtest_main</code>，则需要在<code>main()</code>函数之前调用<code>AddGlobalTestEnvironment()</code>。实现这个的一种方法是定义一个全局变量：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::testing::Environment* <span class="keyword">const</span> foo_env =</span><br><span class="line"></span><br><span class="line">    ::testing::AddGlobalTestEnvironment(<span class="keyword">new</span> FooEnvironment);</span><br></pre></td></tr></table></figure>
<p>但是，强烈建议编写自己的<code>main()</code>并在其中调用<code>AddGlobalTestEnvironment()</code>，因为依赖全局变量的初始化会使代码更加难以阅读，当从不同的翻译单元注册多个environment时，可能会导致问题，并且在environment之间也会存在依赖管理依赖关系（编译器不保证初始化来自不同翻译单元的全局变量的顺序）。</p>
<h2 id="值参数化测试">值参数化测试</h2>
<p>值参数化测试允许使用不同的参数测试代码，而无需编写同一测试的多个副本。 这在许多情况下很有用，例如：</p>
<ul>
<li>有一段代码，其行为受到一个或多个命令行标志的影响，想要确保代码在这些标志取各种值的情况下都能正确执行。</li>
<li>要测试面向对象的接口的不同实现。</li>
<li>想要用不同的输入测试代码（数据驱动测试）, 这一特性很容易被滥用，请谨慎使用。</li>
</ul>
<h3 id="如何编写值参数化测试">如何编写值参数化测试</h3>
<p>为了编写值参数化测试，首先要定义一个<code>testing::Test</code>和<code>testing::WithParamInterface&lt;T&gt;</code>(后者是纯接口类)的派生类-<code>fixture</code>类，其中<code>T</code>是参数类型。为了便于书写，可以直接从<code>testing::TestWithParam&lt;T&gt;</code>派生，它是<code>testing::Test</code>和<code>testing::WithParamInterface&lt;T&gt;</code>共同派生出来的一个类。<code>T</code>可以是任意可拷贝类型，如果它是一个裸指针，还需要负责指针的生命周期。</p>
<p>注意：如果测试定义了<code>SetUpTestCase()</code>或<code>TearDownTestCase()</code>，则必须将它们声明为<strong>public</strong>而不是<strong>protected</strong>，才能使用<code>TEST_P</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> :</span></span><br><span class="line">    <span class="keyword">public</span> testing::TestWithParam&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; &#123;</span><br><span class="line">  <span class="comment">// You can implement all the usual fixture class members here.</span></span><br><span class="line">  <span class="comment">// To access the test parameter, call GetParam() from class</span></span><br><span class="line">  <span class="comment">// TestWithParam&lt;T&gt;.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or, when you want to add parameters to a pre-existing fixture class:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarTest</span> :</span> <span class="keyword">public</span> BaseTest,</span><br><span class="line">                <span class="keyword">public</span> testing::WithParamInterface&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，使用<code>TEST_P</code>宏根据需要使用此fixture定义尽可能多的测试模式。<code>_P</code>后缀的意思是“参数化”或“模式”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TEST_P(FooTest, DoesBlah) &#123;</span><br><span class="line">  <span class="comment">// Inside a test, access the test parameter with the GetParam() method</span></span><br><span class="line">  <span class="comment">// of the TestWithParam&lt;T&gt; class:</span></span><br><span class="line">  EXPECT_TRUE(foo.Blah(GetParam()));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST_P(FooTest, HasBlahBlah) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>INSTANTIATE_TEST_CASE_P</code>，使用任何一组想要的参数来实例化test suite。googletest定义了许多函数来生成测试参数。它们返回我们所称的参数生成器。下面是它们的摘要，这些函数都在<code>testing</code>命名空间中：</p>
<table>
<colgroup>
<col style="width: 44%">
<col style="width: 55%">
</colgroup>
<thead>
<tr class="header">
<th>Parameter Generator</th>
<th>Behavior</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Range(begin, end [, step])</code></td>
<td>Yields values <code>&#123;begin, begin+step, begin+step+step, ...&#125;</code>. The values do not include <code>end</code>. <code>step</code> defaults to 1.</td>
</tr>
<tr class="even">
<td><code>Values(v1, v2, ..., vN)</code></td>
<td>Yields values <code>&#123;v1, v2, ..., vN&#125;</code>.</td>
</tr>
<tr class="odd">
<td><code>ValuesIn(container)</code> and <code>ValuesIn(begin,end)</code></td>
<td>Yields values from a C-style array, an STL-style container, or an iterator range <code>[begin, end)</code></td>
</tr>
<tr class="even">
<td><code>Bool()</code></td>
<td>Yields sequence <code>&#123;false, true&#125;</code>.</td>
</tr>
<tr class="odd">
<td><code>Combine(g1, g2, ..., gN)</code></td>
<td>Yields all combinations (Cartesian product) as std::tuples of the values generated by the <code>N</code> generators.</td>
</tr>
</tbody>
</table>
<p>以下语句将实例化<code>FooTest</code> 测试套件(test suite)中的测试，试参数参数值分别为<code>“ meeny”</code>，<code>“ miny”</code>和<code>“ moe”</code>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSTANTIATE_TEST_CASE_P(InstantiationName,</span><br><span class="line">                         FooTest,</span><br><span class="line">                         testing::Values(<span class="string">&quot;meeny&quot;</span>, <span class="string">&quot;miny&quot;</span>, <span class="string">&quot;moe&quot;</span>));            </span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：上面的代码必须放在全局或命名空间范围，而不是函数中。</p>
<p><strong>注意</strong>：不要忘记这一步！ 如果忘记了，那么测试会默默地通过，但是其实没有任何套件运行！</p>
<p>目前正在进行一些工作，以使<code>GoogleTestVerification</code>测试套件能够发现省略了<code>INSTANTIATE_TEST_SUITE_P</code>，并将该行为标记为一个错误。 如果有一个测试套件遗漏了<code>INSTANTIATE_TEST_SUITE_P</code>但不用视作一个错误，例如，它位于可能由于其他原因而链接到的库中，或者测试用例列表是动态的并且可能为空，那么可以通过以下方式来标记测试套件以取消此检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);</span><br></pre></td></tr></table></figure>
<p>为了区分该模式的不同实例，<code>INSTANTIATE_TEST_SUITE_P</code>的第一个参数将作为一个前缀添加到实际的测试套件名称中。 请记住为不同的实例选择唯一的前缀。 上面实例化的测试将具有以下名称：</p>
<ul>
<li><code>InstantiationName/FooTest.DoesBlah/0</code> for <code>"meeny"</code></li>
<li><code>InstantiationName/FooTest.DoesBlah/1</code> for <code>"miny"</code></li>
<li><code>InstantiationName/FooTest.DoesBlah/2</code> for <code>"moe"</code></li>
<li><code>InstantiationName/FooTest.HasBlahBlah/0</code> for <code>"meeny"</code></li>
<li><code>InstantiationName/FooTest.HasBlahBlah/1</code> for <code>"miny"</code></li>
<li><code>InstantiationName/FooTest.HasBlahBlah/2</code> for <code>"moe"</code></li>
</ul>
<p>这些名称可以在<code>--gtest_filter</code>中使用</p>
<p>下面的语句将再次实例化<code>FooTest</code>的所有测试，每个测试的参数值分别为<code>“ cat”</code>和<code>“ dog”</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">char</span>* pets[] = &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>&#125;;</span><br><span class="line">INSTANTIATE_TEST_SUITE_P(AnotherInstantiationName, FooTest,</span><br><span class="line">                         testing::ValuesIn(pets));</span><br><span class="line">                         </span><br></pre></td></tr></table></figure>
<p>上面的命名实例化的测试名称如下</p>
<ul>
<li><code>AnotherInstantiationName/FooTest.DoesBlah/0</code> for <code>"cat"</code></li>
<li><code>AnotherInstantiationName/FooTest.DoesBlah/1</code> for <code>"dog"</code></li>
<li><code>AnotherInstantiationName/FooTest.HasBlahBlah/0</code> for <code>"cat"</code></li>
<li><code>AnotherInstantiationName/FooTest.HasBlahBlah/1</code> for <code>"dog"</code></li>
</ul>
<p>请注意，<code>INSTANTIATE_TEST_CASE_P</code>将实例化给定测试套件中的所有测试，无论它们的定义在<code>INSTANTIATE_TEST_CASE_P</code>语句之前还是之后。</p>
<h3 id="创建值参数化抽象测试">创建值参数化抽象测试</h3>
<p>之前，我们在同一源文件中定义并实例化<code>FooTest</code>。 有时可能需要在库中定义值参数化的测试，然后让别人实例化它们， 这种模式称为抽象测试。 作为其使用的一个示例，在设计接口时，可以编写标准的抽象测试套件（也许使用工厂函数作为测试参数），期望该接口的所有实现都能通过。 当其他人实现这个接口时，他们可以实例化你的套件以获得所有接口一致性测试。</p>
<p>应该按如下形式组织代码来定义抽象测试：</p>
<ol type="1">
<li>将定义参数化测试fixture的类定义在一个头文件里，如<code>foo_param_test.h</code>，把这个看做是对抽象测试的声明。</li>
<li>将<code>TEST_P</code>定义放在<code>foo_param_test.cc</code>中，其中引用头文件<code>foo_param_test.h</code>， 将此视为实现抽象测试。</li>
</ol>
<p>定义它们之后，可以通过引用<code>foo_param_test.h</code>头文件，调用<code>INSTANTIATE_TEST_SUITE_P（）</code>函数，并且依赖包含<code>foo_param_test.cc</code>的目标库来实例化它们。 这样就可以在不同的源文件中多次实例化同一抽象测试套件。</p>
<h3 id="为值参数化的测试参数指定名称">为值参数化的测试参数指定名称</h3>
<p><code>INSTANTIATE_TEST_SUITE_P()</code>的最后一个可选参数允许使用者定制一个能够基于测试参数生成的测试名后缀的函数。该函数应接受一个类型为<code>testing::TestParamInfo &lt;class ParamType&gt;</code>的参数，并返回<code>std :: string</code>。</p>
<p><code>testing::PrintToStringParamName</code>是一个内置的测试名后缀生成器，它返回<code>testing::PrintToString(GetParam())</code>的值。它不适用于<code>std::string</code>或C字符串。</p>
<p>注意：测试名称必须是非空的，唯一的，并且只能包含ASCII字母数字字符。特别是，它们不应包含下划线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestSuite</span> :</span> <span class="keyword">public</span> testing::TestWithParam&lt;<span class="keyword">int</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">TEST_P(MyTestSuite, MyTest)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Example Test Param: &quot;</span> &lt;&lt; GetParam() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INSTANTIATE_TEST_SUITE_P(MyGroup, MyTestSuite, testing::Range(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">                         testing::PrintToStringParamName());</span><br></pre></td></tr></table></figure>
<p>提供自定义函数可以更好地控制测试参数名称的生成，尤其是对于自动转换不会生成有用的参数名称的类型(例如，如上所述的字符串)。下面的示例说明了多个参数，枚举类型和字符串的情况，并演示了如何组合生成器。为了简洁起见，它使用lambda表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">MyType</span> &#123;</span> MY_FOO = <span class="number">0</span>, MY_BAR = <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestSuite</span> :</span> <span class="keyword">public</span> testing::TestWithParam&lt;<span class="built_in">std</span>::tuple&lt;MyType, <span class="built_in">string</span>&gt;&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">INSTANTIATE_TEST_SUITE_P(</span><br><span class="line">    MyGroup, MyTestSuite,</span><br><span class="line">    testing::Combine(</span><br><span class="line">        testing::Values(MyType::VALUE_0, MyType::VALUE_1),</span><br><span class="line">        testing::ValuesIn(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)),</span><br><span class="line">    [](<span class="keyword">const</span> testing::TestParamInfo&lt;MyTestSuite::ParamType&gt;&amp; info) &#123;</span><br><span class="line">      <span class="built_in">string</span> name = absl::StrCat(</span><br><span class="line">          <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(info.param) == MY_FOO ? <span class="string">&quot;Foo&quot;</span> : <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;_&quot;</span>,</span><br><span class="line">          <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(info.param));</span><br><span class="line">      absl::c_replace_if(name, [](<span class="keyword">char</span> c) &#123; <span class="keyword">return</span> !<span class="built_in">std</span>::<span class="built_in">isalnum</span>(c); &#125;, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="类型测试">类型测试</h2>
<p>假设现在具有同一个接口的多个实现，并且想要确保它们都满足一些共同的要求。或者，可能已经定义了几种应该符合相同“概念”的类型，并且想要对其进行验证。在两种情况下，都希望针对不同类型重复相同的测试逻辑。</p>
<p>虽然可以为每种要测试的类型编写一个<code>TEST</code>或<code>TEST_F</code>（甚至可以将测试逻辑分解为从TEST调用的功能模板中），但这种操作很繁琐且无法扩展，如果要对n种类型进行m个测试，最终将编写m * n个<code>TEST</code>。</p>
<p>类型化测试允许在一系列的类型上重复相同的测试逻辑。尽管编写类型测试时必须知道类型列表，但只需要编写一次测试逻辑。 下面是操作方式：</p>
<p>首先，定义一个从<code>::testing::Test</code>派生的fixture类模板，应当通过某种类型对其进行参数化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; List;</span><br><span class="line">  <span class="keyword">static</span> T shared_;</span><br><span class="line">  T value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，将类型列表与测试套件相关联，将对该列表中的每种类型重复此操作:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyTypes = ::testing::Types&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;;</span><br><span class="line">TYPED_TEST_SUITE(FooTest, MyTypes);</span><br></pre></td></tr></table></figure>
<p>类型别名（<code>using</code>或<code>typedef</code>）是<code>TYPED_TEST_SUITE</code>宏正确解析所必需的。否则，编译器会认为类型列表中的每个逗号都会引入一个新的宏参数。</p>
<p>然后，使用<code>TYPED_TEST（）</code>代替<code>TEST_F（）</code>为该测试套件定义类型测试。 可以根据需要重复多次：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TYPED_TEST(FooTest, DoesBlah) &#123;</span><br><span class="line">  <span class="comment">// Inside a test, refer to the special name TypeParam to get the type</span></span><br><span class="line">  <span class="comment">// parameter.  Since we are inside a derived class template, C++ requires</span></span><br><span class="line">  <span class="comment">// us to visit the members of FooTest via &#x27;this&#x27;.</span></span><br><span class="line">  TypeParam n = this-&gt;value_;</span><br><span class="line">  <span class="comment">// To visit static members of the fixture, add the &#x27;TestFixture::&#x27;</span></span><br><span class="line">  <span class="comment">// prefix.</span></span><br><span class="line">  n += TestFixture::shared_;</span><br><span class="line">  <span class="comment">// To refer to typedefs in the fixture, add the &#x27;typename TestFixture::&#x27;</span></span><br><span class="line">  <span class="comment">// prefix.  The &#x27;typename&#x27; is required to satisfy the compiler.</span></span><br><span class="line">  typename TestFixture::List values;</span><br><span class="line">  values.push_back(n);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">TYPED_TEST(FooTest, HasPropertyA) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型参数化测试">类型参数化测试</h2>
<p>类型参数化测试与类型测试类似，不同之处在于它们不需要提前知道类型列表。相反，可以先定义测试逻辑，然后再使用不同的类型列表实例化它，甚至可以在同一程序中多次实例化它。</p>
<p>如果要设计接口或概念，则可以定义一组类型参数化的测试，以验证接口/概念的任何有效实现应具有的属性。 然后，每个实现的作者都可以使用其类型实例化测试套件以验证其是否符合要求，而不必重复编写类似的测试。 例如：</p>
<p>首先，定义一个像类型测试那样的fixture类模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后声明将定义一个类型参数化的测试套件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPED_TEST_SUITE_P(FooTest);</span><br></pre></td></tr></table></figure>
<p>然后，使用<code>TYPED_TEST_P（）</code>定义类型参数化的测试。 可以根据需要重复多次：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TYPED_TEST_P(FooTest, DoesBlah) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inside a test, refer to TypeParam to get the type parameter.</span></span><br><span class="line"></span><br><span class="line">  TypeParam n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TYPED_TEST_P(FooTest, HasPropertyA) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>现在，棘手的部分是，需要使用<code>REGISTER_TYPED_TEST_SUITE_P</code>宏注册所有测试模式，然后才能实例化它们。 宏的第一个参数是测试套件名称, 其余的是此测试套件中测试的名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REGISTER_TYPED_TEST_SUITE_P(FooTest,</span><br><span class="line"></span><br><span class="line">                            DoesBlah, HasPropertyA);</span><br></pre></td></tr></table></figure>
<p>最后，您可以随意用所需的类型实例化模式。 如果将上面的代码放在头文件中，则可以<code>#include</code>将其包含在多个C ++源文件中，并将其实例化多次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ::testing::Types&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; MyTypes;</span><br><span class="line">INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);</span><br></pre></td></tr></table></figure>
<p>为了区分模式的不同实例,<code>INSTANTIATE_TYPED_TEST_SUITE_P</code>宏的第一个参数是一个前缀，它将添加到实际的测试套件名称中。 请记住为不同的实例选择唯一的前缀。</p>
<p>在类型列表仅包含一种类型的特殊情况下，您可以直接编写该类型，而无需<code>::testing::Types &lt;...&gt;</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<h2 id="测试private代码">测试private代码</h2>
<p>如果更改软件的内部实现，只要用户看不到更改，测试就不会中断。因此，根据黑盒测试原则，大多数时候应该通过其公共接口来测试代码。</p>
<p>如果仍然需要测试内部实现代码，请考虑是否有更好的设计。需要测试内部实现通常表明该类做了太多事情。考虑提取一个实现类，并对其进行测试，然后在原始类中使用该实现类。</p>
<p>如果一定要测试非公共接口代码的话，例如以下两种情况：</p>
<ul>
<li>静态函数（和静态成员函数不同）或者没有命名的命名空间</li>
<li>private或者protected的类成员</li>
</ul>
<p>可以使用独特的方法来测试他们：</p>
<ul>
<li>未命名名称空间中的静态函数和定义/声明仅在同一编译单元中可见。要对其进行测试，可以将需要测试的<code>.cc</code>文件<code>#include</code>到<code>* _test.cc</code>文件中。（#include <code>.cc</code>文件不是重用代码的好方法，不应该在生产代码中这样做！）</li>
<li>更好的方法是将私有代码移到<code>foo::internal</code>命名空间中，其中<code>foo</code>是项目通常使用的命名空间，并将私有声明放入<code>* -internal.h</code>文件中。编写的<code>.cc</code>文件和测试允许包含此内部标头，但客户端则不允许。这样，就可以完全测试内部实现，而不会泄漏给客户。</li>
<li>私有类成员只能在类内部或由友元访问。 要访问类的私有成员，可以将test fixture声明为类的友元，并在fixture中定义访问器。然后，使用test fixture进行的测试就可以通过fixture中的访问器访问生产类的私有成员。请注意，即使fixture是生产类的友元，测试也不会自动成为生产类的友元，因为它们是在fixture的子类中定义的。</li>
<li>测试私有成员的另一种方法是将它们重构为实现类，然后在<code>* -internal.h</code>文件中对其进行声明。客户端不允许包含此标头，但是测试代码可以。这就是所谓的Pimpl（私有实现）习惯用法。</li>
</ul>
<p>或者可以生产类中添加以下代码，声明一个独立的测试作为被测试类的友元：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FRIEND_TEST(TestSuiteName, TestName);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  FRIEND_TEST(FooTest, BarReturnsZeroOnNull);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Bar</span><span class="params">(<span class="keyword">void</span>* x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo_test.cc</span></span><br><span class="line">...</span><br><span class="line">TEST(FooTest, BarReturnsZeroOnNull) &#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  EXPECT_EQ(foo.Bar(<span class="literal">NULL</span>), <span class="number">0</span>);  <span class="comment">// Uses Foo&#x27;s private member Bar().</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当测试类在命名空间中定义时要特别注意：如果希望它们成为生产类的友元，则应该在生产类的同一名称空间中定义test fixture和测试。 例如，如果要测试的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> my_namespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FooTest</span>;</span></span><br><span class="line">  FRIEND_TEST(FooTest, Bar);</span><br><span class="line">  FRIEND_TEST(FooTest, Baz);</span><br><span class="line">  ... definition of the <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> ...</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace my_namespace</span></span><br></pre></td></tr></table></figure>
<p>那么测试代码应该如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> my_namespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(FooTest, Bar) &#123; ... &#125;</span><br><span class="line">TEST_F(FooTest, Baz) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace my_namespace</span></span><br></pre></td></tr></table></figure>
<h2 id="捕获失败">捕获失败</h2>
<p>如果要在googletest之上构建测试工具集，那么应该使用什么框架测试这个测试工具集？当然是 googletest。</p>
<p>所需要面临的挑战是验证改测试工具集是否能够正确报告故障。在通过引发异常报告失败的框架中，可以捕获异常并对其进行断言。 但是googletest不使用异常，那么应该如何测试一段代码是否会产生预期的失败？</p>
<p><code>gunit-spi.h</code>包含一些用于执行此操作的结构。在<code>#include</code>该头文件之后，就可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_FATAL_FAILURE(statement, substring);</span><br></pre></td></tr></table></figure>
<p>来断言该包含给定<code>substring</code>的消息的<code>statement</code>在当前线程中是否产生了致命错误（例如<code>ASSERT_ *</code>），或使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_NONFATAL_FAILURE(statement, substring);</span><br></pre></td></tr></table></figure>
<p>来断言非致命错误。</p>
<p>上述宏仅检查当前线程中的失败，以确定这类期望的结果。 如果<code>statement</code>创建新线程，这些线程中的故障也将被忽略。如果您还想捕获其他线程中的故障，请改用以下宏之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_FATAL_FAILURE_ON_ALL_THREADS(statement, substring);</span><br><span class="line">EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS(statement, substring);</span><br></pre></td></tr></table></figure>
<p>注意：Windows暂时不支持来自多个线程的断言</p>
<p>从技术上来说，还有以下警告：</p>
<ol type="1">
<li>这些宏不能使用流导入失败信息</li>
<li><code>EXPECT_FATAL_FAILURE&#123;_ON_ALL_THREADS&#125;()</code>中的<code>statement</code>不能引用非静态变量或者<code>this</code>对象的非静态成员</li>
<li><code>EXPECT_FATAL_FAILURE&#123;_ON_ALL_THREADS&#125;()</code>中的<code>statement</code>不能返回值。</li>
</ol>
<h2 id="程序化的注册测试">程序化的注册测试</h2>
<p><code>TEST</code>宏可处理绝大多数的测试用例，但是也会有极少数情况下需要运行时注册逻辑。 对于这些情况，框架提供<code>::testing::RegisterTest</code>来允许调用者动态注册任意测试。</p>
<p>这是仅在<code>TEST</code>宏不足时才使用的高级API。 应该尽可能首选宏，因为它们避免了调用此函数的大部分复杂性。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Factory&gt;</span><br><span class="line"><span class="function">TestInfo* <span class="title">RegisterTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* test_suite_name, <span class="keyword">const</span> <span class="keyword">char</span>* test_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span>* type_param, <span class="keyword">const</span> <span class="keyword">char</span>* value_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">int</span> line, Factory factory)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>factory</code>参数是可调用的（可移动构造的）<code>factory</code>对象或函数指针，它创建Test对象的新实例。它处理呼叫者的所有权。 可调用对象的签名为<code>Fixture *（）</code>，其中<code>Fixture</code>是测试的test fixture类。所有的测试使用相同<code>test_suite_name</code>注册，并且必须返回相同的fixture类型。 这会在运行时进行检查。</p>
<p>该框架将从factory推断出fixture类，并将为此调用<code>SetUpTestSuite</code>和<code>TearDownTestSuite</code>。</p>
<p>必须在调用<code>RUN_ALL_TESTS（）</code>之前调用<code>::testing::RegisterTest</code>，否则行为是不确定的。</p>
<p>例如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFixture</span> : <span class="title">public</span> ::<span class="title">testing</span>::<span class="title">Test</span> </span>&#123;</span><br><span class="line"> public:</span><br><span class="line">  <span class="comment">// All of these optional, just like in regular macro usage.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> SetUpTestSuite() &#123; ... &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> TearDownTestSuite() &#123; ... &#125;</span><br><span class="line">  <span class="keyword">void</span> SetUp() override &#123; ... &#125;</span><br><span class="line">  <span class="keyword">void</span> TearDown() override &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> : <span class="title">public</span> <span class="title">MyFixture</span> </span>&#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit MyTest(<span class="built_in">int</span> data) : data_(data) &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> TestBody() override &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  <span class="built_in">int</span> data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RegisterMyTests(<span class="keyword">const</span> std::vector&lt;<span class="built_in">int</span>&gt;&amp; values) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> v : values) &#123;</span><br><span class="line">    ::testing::RegisterTest(</span><br><span class="line">        <span class="string">&quot;MyFixture&quot;</span>, (<span class="string">&quot;Test&quot;</span> + std::to_string(v)).c_str(), nullptr,</span><br><span class="line">        std::to_string(v).c_str(),</span><br><span class="line">        __FILE__, __LINE__,</span><br><span class="line">        <span class="comment">// Important to use the fixture type as the return type here.</span></span><br><span class="line">        [=]() -&gt; MyFixture* &#123; <span class="keyword">return</span> <span class="keyword">new</span> MyTest(v); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char** argv) &#123;</span><br><span class="line">  std::vector&lt;<span class="built_in">int</span>&gt; values_to_test = LoadValuesFromConfig();</span><br><span class="line">  RegisterMyTests(values_to_test);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取当前的测试名">获取当前的测试名</h2>
<p>有时某个功能可能需要知道当前正在运行的测试的名称。 例如，可能使用test fixture的<code>SetUp（）</code>方法来根据正在运行的测试来设置最佳文件名。<code>::testing::TestInfo</code>类具有以下信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> testing &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestInfo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Returns the test suite name and the test name, respectively.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Do NOT delete or free the return value - it&#x27;s managed by the</span></span><br><span class="line">  <span class="comment">// TestInfo class.</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">test_suite_name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获取当前正在运行的测试的<code>TestInfo</code>对象，请对<code>UnitTest</code>单例对象调用<code>current_test_info()</code>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gets information about the currently running test.</span></span><br><span class="line">  <span class="comment">// Do NOT delete the returned object - it&#x27;s managed by the UnitTest class.</span></span><br><span class="line">  <span class="keyword">const</span> ::testing::TestInfo* <span class="keyword">const</span> test_info =</span><br><span class="line">    ::testing::UnitTest::GetInstance()-&gt;current_test_info();</span><br><span class="line"></span><br><span class="line">  printf(<span class="string">&quot;We are in test %s of test suite %s.\n&quot;</span>,</span><br><span class="line">         test_info-&gt;name(),</span><br><span class="line">         test_info-&gt;test_suite_name());      </span><br></pre></td></tr></table></figure>
<p>如果没有测试在运行，<code>current_test_info（）</code>返回一个空指针。 特别是，不能从<code>TestSuiteSetUp（）</code>，<code>TestSuiteTearDown（）</code>（可以隐式知道测试套件名称）或他们调用的函数中获取测试套件名称。</p>
<h2 id="通过处理测试事件来扩展googletest">通过处理测试事件来扩展googletest</h2>
<p>googletest提供了事件监听器API，可让接收有关测试程序进度和测试失败的通知。可以监听的事件包括测试程序，测试套件或测试方法的开始和结束。 可以使用此API来扩充或替换标准控制台输出，替换XML输出或提供完全不同形式的输出，例如GUI或数据库。还可以将测试事件用作检查点以实现资源泄漏检查器。</p>
<h3 id="定义事件监听器">定义事件监听器</h3>
<p>要定义事件监听器，可以将<code>testing :: TestEventListener</code>或<code>testing :: EmptyTestEventListener</code>子类化。前者是一个（抽象的）接口，可以覆<code>override</code>每个纯虚拟方法来处理测试事件（例如，测试开始时， <code>OnTestStart（）</code>方法将被调用。） 后者提供了接口中所有方法的空实现，因此子类只需要<code>override</code>其关心的方法。</p>
<p>触发事件时，其上下文作为参数传递给处理程序函数。 将使用以下参数类型：</p>
<ul>
<li>UnitTest反映整个测试程序的状态</li>
<li>TestSuite具有有关测试套件的信息，其中可以包含一个或多个测试</li>
<li>TestInfo包含一个测试的状态</li>
<li>TestPartResult表示测试断言的结果</li>
</ul>
<p>事件处理程序函数可以检查其接收到的参数，以找到有关事件和测试程序状态的令人感兴趣的信息。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinimalistPrinter</span> :</span> <span class="keyword">public</span> ::testing::EmptyTestEventListener &#123;</span><br><span class="line">    <span class="comment">// Called before a test starts.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTestStart</span><span class="params">(<span class="keyword">const</span> ::testing::TestInfo&amp; test_info)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;*** Test %s.%s starting.\n&quot;</span>,</span><br><span class="line">             test_info.test_suite_name(), test_info.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called after a failed assertion or a SUCCESS().</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTestPartResult</span><span class="params">(<span class="keyword">const</span> ::testing::TestPartResult&amp; test_part_result)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s in %s:%d\n%s\n&quot;</span>,</span><br><span class="line">             test_part_result.failed() ? <span class="string">&quot;*** Failure&quot;</span> : <span class="string">&quot;Success&quot;</span>,</span><br><span class="line">             test_part_result.file_name(),</span><br><span class="line">             test_part_result.line_number(),</span><br><span class="line">             test_part_result.summary());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called after a test ends.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTestEnd</span><span class="params">(<span class="keyword">const</span> ::testing::TestInfo&amp; test_info)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;*** Test %s.%s ending.\n&quot;</span>,</span><br><span class="line">             test_info.test_suite_name(), test_info.name());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用事件监听器">使用事件监听器</h3>
<p>在<code>main()</code>函数调用<code>RUN_ALL_TESTS()</code>前，在GTEST事件监听器列表中添加定义的监听器的实例化来使用它。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, char** argv) &#123;</span><br><span class="line">  ::testing::InitGoogleTest(&amp;argc, argv);</span><br><span class="line">  <span class="comment">// Gets hold of the event listener list.</span></span><br><span class="line">  ::testing::TestEventListeners&amp; listeners =</span><br><span class="line">        ::testing::UnitTest::GetInstance()-&gt;listeners();</span><br><span class="line">  <span class="comment">// Adds a listener to the end.  googletest takes the ownership.</span></span><br><span class="line">  listeners.Append(<span class="keyword">new</span> MinimalistPrinter);</span><br><span class="line">  <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅有一个问题：默认的测试结果打印器仍然有效，因此定义的输出将于原始的输出混合在一起。 要取消显示默认打印器，只需将其从事件侦听器列表中释放并删除即可。可以通过添加一行代码来做到这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> listeners.Release(listeners.default_result_printer());</span><br><span class="line">listeners.Append(<span class="keyword">new</span> MinimalistPrinter);</span><br><span class="line"><span class="keyword">return</span> RUN_ALL_TESTS();</span><br></pre></td></tr></table></figure>
<p>现在，坐下来享受与默认的测试完全不同的输出。</p>
<p>可以在列表中追加一个以上的侦听器。当触发<code>On * Start（）</code>或<code>OnTestPartResult（）</code>事件时，侦听器将按照它们在列表中出现的顺序来接收事件（因为新的侦听器被添加到列表的末尾，默认的文本打印器和默认的XML生成器将首先收到事件）。侦听器将以相反的顺序接收<code>On * End（）</code>事件。</p>
<h3 id="生成失败监听器">生成失败监听器</h3>
<p>处理事件时，可以使用引发故障的宏（<code>EXPECT _ *（）</code>，<code>ASSERT _ *（）</code>，<code>FAIL（）</code>等）。但他们有一些限制：</p>
<ol type="1">
<li>无法在<code>OnTestPartResult（）</code>中产生任何故障（否则将导致递归调用<code>OnTestPartResult（）</code>）</li>
<li>不允许处理<code>OnTestPartResult（）</code>的侦听器生成任何故障。</li>
</ol>
<p>将侦听器添加到侦听器列表时，应该将处理<code>OnTestPartResult（）</code>的侦听器放在可能产生故障的侦听器之前。这样可以确保后者产生的故障归因于前者的正确测试。</p>
<h2 id="运行测试程序更多选项">运行测试程序：更多选项</h2>
<p>googletest测试程序是普通的可执行文件。构建完成后，可以直接运行它们，并通过以下环境变量和/或命令行标志影响它们的行为。为了使这些标志起作用，您的程序必须在调用<code>RUN_ALL_TESTS()</code>之前调用<code>::testing::InitGoogleTest()</code>。</p>
<p>要查看受支持的标志及其用法的列表，请使用--help标志运行测试程序。 也可以使用-h，-？或/？作为缩写。</p>
<p>如果同时由环境变量和标志指定选项，则后者优先。</p>
<h3 id="选择测试">选择测试</h3>
<p><strong>列出测试名字</strong></p>
<p>有时，有必要在运行它们之前在程序中列出可用的测试，以便在需要时可以应用过滤器。包含标志<code>--gtest_list_tests</code>会覆盖所有其他标志，并以以下格式列出测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TestSuite1.</span><br><span class="line">  TestName1</span><br><span class="line">  TestName2</span><br><span class="line">TestSuite2.</span><br><span class="line">  TestName</span><br></pre></td></tr></table></figure>
<p>如果提供了该标志，则列出的测试均不会实际运行， 此标志没有相应的环境变量。</p>
<p><strong>运行测试的子集</strong></p>
<p>默认情况下，googletest程序会运行用户定义的所有测试。有些情况下，只想运行一部分测试（例如用于调试或快速验证更改）。如果将<code>GTEST_FILTER</code>环境变量或<code>--gtest_filter</code>标志设置为过滤器字符串，则googletest将仅运行其名称（以<code>TestSuiteName.TestName</code>的形式）与过滤器匹配的测试。</p>
<p>过滤器的格式是由<code>':'</code>分隔的通配符模式列表（称为正模式），可以选择后跟<code>“-”</code>和另一个由<code>“：”</code>分隔的模式列表（称为负模式）。当且仅当测试匹配任何正模式但不匹配任何负模式时，测试才与过滤器匹配。</p>
<p>模式可以包含<code>“ *”</code>（与任何字符串匹配）或<code>“？”</code>（匹配任何单个字符）。为方便起见，过滤器<code>“ * -NegativePatterns”</code>也可以写为<code>“ -NegativePatterns”</code>。</p>
<p>例如：</p>
<ul>
<li><code>./foo_test</code> 没有标志，所以运行所有的测试</li>
<li><code>./foo_test --gtest_filter=*</code> 也运行所有测试，因为他匹配所有东西</li>
<li><code>./foo_test --gtest_filter=FooTest.*</code>运行<code>FooTest</code>测试套件里的所有测试</li>
<li><code>./foo_test --gtest_filter=*Null*:*Constructor*</code>运行名字里有<code>NULL</code>或者<code>Constructor</code>的测试</li>
<li><code>./foo_test --gtest_filter=-*DeathTest.*</code>运行所有非死亡测试</li>
<li><code>./foo_test --gtest_filter=FooTest.*-FooTest.Bar</code>运行测试套件<code>FooTest</code>中除了<code>FooTest.Bar</code>的其他测试</li>
<li><code>./foo_test --gtest_filter=FooTest.*:BarTest.*-FooTest.Bar:BarTest.Foo</code>运行测试套件<code>FooTest</code>中除了<code>FooTest.Bar</code>的测试以及测试套件<code>BarTest</code>中除了<code>BarTest.foo</code>的其他测试</li>
</ul>
<p><strong>短暂禁用测试</strong></p>
<p>如果有无法立即修复的损坏测试，则可以在其名称中添加<code>DISABLED_</code>前缀,这会将其从执行中排除。这比注释掉代码或使用<code>#if 0</code>更好，因为被禁用的测试仍然会被编译。</p>
<p>如果需要禁用测试套件中的所有测试，则可以将<code>DISABLED_</code>添加到每个测试名称的前面，或者将其添加到测试套件名称的前面。</p>
<p>例如，下面的测试不会运行但是仍然会被编译:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tests that Foo does Abc.</span></span><br><span class="line">TEST(FooTest, DISABLED_DoesAbc) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DISABLED_BarTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests that Bar does Xyz.</span></span><br><span class="line">TEST_F(DISABLED_BarTest, DoesXyz) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>注意：此功能仅应用于暂时性的禁止测试。之后仍然需要修复已禁用的测试。如果测试程序包含任何禁用的测试，则googletest会打印一条横幅来提醒你。</p>
<p>提示：您可以轻松使用<code>gsearch</code>和/或<code>grep</code>来获取禁用的测试的数量，此数字可用作提高测试质量的指标。</p>
<p><strong>暂时运行不可运行的测试</strong></p>
<p>要将禁用的测试包括在测试执行中，只需使用<code>--gtest_also_run_disabled_tests</code>标志调用测试程序或将<code>GTEST_ALSO_RUN_DISABLED_TESTS</code>环境变量设置为非<code>0</code>的值即可。您可以将其与<code>--gtest_filter</code>标志结合使用，以进一步选择要运行的禁用测试 。</p>
<h3 id="重复测试">重复测试</h3>
<p>偶尔，会遇到测试结果是不确定值的测试。也许它只会在1％的时间内失败，这使得在调试器中重现该错误变得相当困难。这可能是造成挫败感的主要原因。</p>
<p><code>--gtest_repeat</code>标志允许多次重复程序中的所有（或选定的）测试方法。希望不稳定的测试最终会失败，并提供调试的机会。 使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ foo_test --gtest_repeat=<span class="number">1000</span></span><br><span class="line">Repeat foo_test <span class="number">1000</span> times <span class="keyword">and</span> don<span class="number">&#x27;</span>t stop at failures.</span><br><span class="line"></span><br><span class="line">$ foo_test --gtest_repeat=<span class="number">-1</span></span><br><span class="line">A negative count means repeating forever.</span><br><span class="line"></span><br><span class="line">$ foo_test --gtest_repeat=<span class="number">1000</span> --gtest_break_on_failure</span><br><span class="line">Repeat foo_test <span class="number">1000</span> times, stopping at the first failure.  This</span><br><span class="line">is especially useful when running under a debugger: when the test</span><br><span class="line">fails, it will drop into the debugger <span class="keyword">and</span> you can then inspect</span><br><span class="line">variables <span class="keyword">and</span> stacks.</span><br><span class="line"></span><br><span class="line">$ foo_test --gtest_repeat=<span class="number">1000</span> --gtest_filter=FooBar.*</span><br><span class="line">Repeat the tests whose name matches the filter <span class="number">1000</span> times.</span><br></pre></td></tr></table></figure>
<p>如果测试程序包含<code>global set-up/tear-down</code>代码，则在每次迭代中也会重复执行，因为其中可能会出现脆弱性。还可以通过设置<code>GTEST_REPEAT</code>环境变量来指定重复计数。</p>
<h3 id="乱序测试">乱序测试</h3>
<p>可以指定<code>--gtest_shuffle</code>标志（或将<code>GTEST_SHUFFLE</code>环境变量设置为<code>1</code>）以按随机顺序在程序中运行测试。这有助于揭示测试之间的不良依存关系</p>
<p>默认情况下，googletest使用当前时间当做计算随机数的种子，因此每次都会得到不同的序列。控制台输出包括随机种子值，以便以后可以重现与测试序列相关的失败。如果要明确指定随机种子，请使用<code>--gtest_random_seed = SEED</code>标志（或设置<code>GTEST_RANDOM_SEED</code>环境变量），其中<code>SEED</code>是[0，99999]范围内的整数。种子值0很特殊：它告诉googletest执行从当前时间获得种子的默认行为。</p>
<p>如果将其与<code>--gtest_repeat = N</code>结合使用，则googletest在每次迭代中选择其他随机种子，并重新随机排列测试。</p>
<h3 id="控制测试的输出">控制测试的输出</h3>
<p><strong>给终端输出标记颜色</strong></p>
<p>GTEST可以使用颜色标记终端输出，让用户更容易发现重要信息。</p>
<p>您可以将<code>GTEST_COLOR</code>环境变量或<code>--gtest_color</code>命令行标志设置为<code>yes</code>，<code>no</code>或<code>auto</code>（默认设置）来启用颜色，禁用颜色或让googletest决定。 当值为<code>auto</code>时，当且仅当输出到终端并且TERM环境变量设置为<code>xterm</code>或<code>xterm-color</code>时，googletest才会使用颜色。</p>
<p><strong>不显示运行时间</strong></p>
<p>默认情况下，googletest会显示运行每个测试所需的时间。 要禁用它，使用<code>--gtest_print_time = 0</code>命令行标志运行测试程序，或者将<code>GTEST_PRINT_TIME</code>环境变量设置为<code>0</code>。</p>
<p><strong>不输出UTF-8文本</strong></p>
<p>如果断言失败，则googletest会以十六进制编码的字符串以及可读的UTF-8文本（如果其中包含有效的非ASCII UTF-8字符）的形式输出<code>string</code>类型的预期和实际值。如果由于没有兼容UTF-8的输出媒体而不想显示UTF-8文本，请使用<code>--gtest_print_utf8 = 0</code>来运行测试程序，或者将环境变量<code>GTEST_PRINT_UTF8</code>设置为<code>0</code>。</p>
<p><strong>生成XML报告</strong></p>
<p>googletest除了可以正常输出文本外，还可以输出详细的XML报告。该报告包含每个测试的持续时间，可以帮助确定慢速测试。仪表板还使用该报告显示每个测试方法的错误消息。</p>
<p>要生成XML报告，请将<code>GTEST_OUTPUT</code>环境变量或<code>--gtest_output</code>标志，设置为字符串<code>“ xml：path_to_output_file”</code>，这将在给定位置创建文件。 也可以只使用字符串<code>“ xml”</code>，在这种情况下，将输出到当前目录的<code>test_detail.xml</code>。</p>
<p>如果指定一个目录（例如，在Linux上为<code>“ xml：output / directory /”</code>或在Windows上为<code>“ xml：output \ directory \”</code>），则googletest将在该目录中创建XML文件，该文件以测试可执行文件命名（例如测试程序<code>foo_test</code>或<code>foo_test.exe</code>的结果为<code>foo_test.xml</code>）。 如果文件已经存在（可能是上次运行遗留下来的文件），则googletest将选择其他名称（例如<code>foo_test_1.xml</code>）以避免覆盖它。</p>
<p>该报告是基于<code>junitreport Ant</code>任务。由于该格式最初是用于Java的，因此需要进行一些解释才能使其适用于googletest测试，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">testsuites</span> <span class="attr">name</span>=<span class="string">&quot;AllTests&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">testsuite</span> <span class="attr">name</span>=<span class="string">&quot;test_case_name&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testcase</span>    <span class="attr">name</span>=<span class="string">&quot;test_name&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">failure</span> <span class="attr">message</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">failure</span> <span class="attr">message</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">failure</span> <span class="attr">message</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testcase</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">testsuite</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">testsuites</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根节点<code>&lt;testsuites&gt;</code>代表整个测试程序</li>
<li><code>&lt;testsuite&gt;</code>元素代表googletest的测试套件</li>
<li><code>&lt;testcase&gt;</code>元素代表googletest的测试函数</li>
</ul>
<p>下面的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEST(MathTest, Addition) &#123; ... &#125;</span><br><span class="line">TEST(MathTest, Subtraction) &#123; ... &#125;</span><br><span class="line">TEST(LogicTest, NonContradiction) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>将生成如下报告：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">testsuites</span> <span class="attr">tests</span>=<span class="string">&quot;3&quot;</span> <span class="attr">failures</span>=<span class="string">&quot;1&quot;</span> <span class="attr">errors</span>=<span class="string">&quot;0&quot;</span> <span class="attr">time</span>=<span class="string">&quot;0.035&quot;</span> <span class="attr">timestamp</span>=<span class="string">&quot;2011-10-31T18:52:42&quot;</span> <span class="attr">name</span>=<span class="string">&quot;AllTests&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">testsuite</span> <span class="attr">name</span>=<span class="string">&quot;MathTest&quot;</span> <span class="attr">tests</span>=<span class="string">&quot;2&quot;</span> <span class="attr">failures</span>=<span class="string">&quot;1&quot;</span> <span class="attr">errors</span>=<span class="string">&quot;0&quot;</span> <span class="attr">time</span>=<span class="string">&quot;0.015&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testcase</span> <span class="attr">name</span>=<span class="string">&quot;Addition&quot;</span> <span class="attr">status</span>=<span class="string">&quot;run&quot;</span> <span class="attr">time</span>=<span class="string">&quot;0.007&quot;</span> <span class="attr">classname</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">failure</span> <span class="attr">message</span>=<span class="string">&quot;Value of: add(1, 1)<span class="symbol">&amp;#x0A;</span>  Actual: 3<span class="symbol">&amp;#x0A;</span>Expected: 2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">failure</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">failure</span> <span class="attr">message</span>=<span class="string">&quot;Value of: add(1, -1)<span class="symbol">&amp;#x0A;</span>  Actual: 1<span class="symbol">&amp;#x0A;</span>Expected: 0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">failure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testcase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testcase</span> <span class="attr">name</span>=<span class="string">&quot;Subtraction&quot;</span> <span class="attr">status</span>=<span class="string">&quot;run&quot;</span> <span class="attr">time</span>=<span class="string">&quot;0.005&quot;</span> <span class="attr">classname</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testcase</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">testsuite</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">testsuite</span> <span class="attr">name</span>=<span class="string">&quot;LogicTest&quot;</span> <span class="attr">tests</span>=<span class="string">&quot;1&quot;</span> <span class="attr">failures</span>=<span class="string">&quot;0&quot;</span> <span class="attr">errors</span>=<span class="string">&quot;0&quot;</span> <span class="attr">time</span>=<span class="string">&quot;0.005&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testcase</span> <span class="attr">name</span>=<span class="string">&quot;NonContradiction&quot;</span> <span class="attr">status</span>=<span class="string">&quot;run&quot;</span> <span class="attr">time</span>=<span class="string">&quot;0.005&quot;</span> <span class="attr">classname</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testcase</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">testsuite</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">testsuites</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的事项：</p>
<ul>
<li><code>&lt;testsuites&gt;</code>或<code>&lt;testsuite&gt;</code>元素的<code>test</code>属性告诉googletest程序或测试套件包含多少个测试函数，而<code>failures</code>属性告诉他们其中有多少失败。</li>
<li><code>time</code>属性以秒为单位表示测试、测试套件或整个测试程序的持续时间。</li>
<li><code>timestamp</code>属性记录测试执行的本地日期和时间。</li>
<li>每个<code>&lt;failure&gt;</code>元素对应一个失败的googletest断言。</li>
</ul>
<p><strong>生成JSON报告</strong></p>
<p>googletest还可以生成JSON报告作为XML的另一种格式。要生成JSON报告，请将<code>GTEST_OUTPUT</code>环境变量或<code>--gtest_output</code>标志，设置为字符串<code>“ json：path_to_output_file”</code>，GTEST将在给定位置创建文件。 也可以只使用字符串<code>“ json”</code>，在这种情况下，可以在当前目录的<code>test_detail.json</code>文件中找到输出。</p>
<p>JSON报告形式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;http://json-schema.org/schema#&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;definitions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;TestCase&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;tests&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;failures&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;disabled&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;time&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;testsuite&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;array&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;items&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;#/definitions/TestInfo&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TestInfo&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;enum&quot;</span>: [<span class="string">&quot;RUN&quot;</span>, <span class="string">&quot;NOTRUN&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;time&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;classname&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;failures&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;array&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;items&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;#/definitions/Failure&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;Failure&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;failures&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;tests&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">&quot;failures&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">&quot;disabled&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">&quot;errors&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;date-time&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;time&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">&quot;testsuites&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;array&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;items&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;#/definitions/TestCase&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该报告使用符合以下JSON编码的Proto3的格式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> googletest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/duration.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message UnitTest &#123;</span><br><span class="line">  <span class="keyword">int32</span> tests = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int32</span> failures = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int32</span> disabled = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int32</span> errors = <span class="number">4</span>;</span><br><span class="line">  google.protobuf.Timestamp timestamp = <span class="number">5</span>;</span><br><span class="line">  google.protobuf.Duration time = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">string</span> name = <span class="number">7</span>;</span><br><span class="line">  repeated TestCase testsuites = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message TestCase &#123;</span><br><span class="line">  <span class="keyword">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int32</span> tests = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int32</span> failures = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int32</span> disabled = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int32</span> errors = <span class="number">5</span>;</span><br><span class="line">  google.protobuf.Duration time = <span class="number">6</span>;</span><br><span class="line">  repeated TestInfo testsuite = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message TestInfo &#123;</span><br><span class="line">  <span class="keyword">string</span> name = <span class="number">1</span>;</span><br><span class="line">  enum Status &#123;</span><br><span class="line">    RUN = <span class="number">0</span>;</span><br><span class="line">    NOTRUN = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Status status = <span class="number">2</span>;</span><br><span class="line">  google.protobuf.Duration time = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">string</span> classname = <span class="number">4</span>;</span><br><span class="line">  message Failure &#123;</span><br><span class="line">    <span class="keyword">string</span> failures = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> <span class="keyword">type</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  repeated Failure failures = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，以下程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEST(MathTest, Addition) &#123; ... &#125;</span><br><span class="line">TEST(MathTest, Subtraction) &#123; ... &#125;</span><br><span class="line">TEST(LogicTest, NonContradiction) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>将有以下输出：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tests&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;failures&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;errors&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;0.035s&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2011-10-31T18:52:42Z&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;AllTests&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;testsuites&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;MathTest&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tests&quot;</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;failures&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;errors&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;0.015s&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;testsuite&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Addition&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;RUN&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;0.007s&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;classname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;failures&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Value of: add(1, 1)\n  Actual: 3\nExpected: 2&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Value of: add(1, -1)\n  Actual: 1\nExpected: 0&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Subtraction&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;RUN&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;0.005s&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;classname&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;LogicTest&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tests&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;failures&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;errors&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;0.005s&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;testsuite&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;NonContradiction&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;RUN&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;0.005s&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;classname&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：JSON文档的确切格式可能会更改。</p>
<h3 id="控制如何报告失败">控制如何报告失败</h3>
<p><strong>将断言失败转变为断点</strong></p>
<p>在debugger下运行测试程序时，如果调试器可以非常方便的捕获断言失败并自动进入交互模式。googletest的<code>break-on-failure</code>模式支持此行为</p>
<p>要启用它，需要将<code>GTEST_BREAK_ON_FAILURE</code>环境变量设置为非<code>0</code>的值。或者可以使用<code>--gtest_break_on_failure</code>命令行标志。</p>
<p><strong>禁用捕获抛出的测试异常</strong></p>
<p>无论是否启用例外，都可以使用googletest。如果测试抛出C ++异常或（在Windows上）结构化异常（SEH），默认情况下googletest会捕获该异常，将其报告为测试失败，然后继续执行下一个测试方法。这使得可以尽可能多的运行测试。另外，在Windows上，未捕获的异常将导致弹出窗口，因此捕获异常可以自动运行测试。</p>
<p>在调试测试失败时，可能希望调试器处理异常，以便可以在引发异常时检查调用堆栈。 为此，请将<code>GTEST_CATCH_EXCEPTIONS</code>环境变量设置为<code>0</code>，或在运行测试时使用<code>--gtest_catch_exceptions = 0</code>标志。</p>
<h2 id="相关参考">相关参考</h2>
<p><a target="_blank" rel="noopener" href="https://google.github.io/googletest/">GoogleTest User’s Guide | GoogleTest</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.ibm.com/technologies/systems/articles/au-googletestingframework/">A quick introduction to the Google C++ Testing Framework – IBM Developer</a></p>
<p><a target="_blank" rel="noopener" href="http://www.yolinux.com/TUTORIALS/Cpp-GoogleTest.html">GoogleTest: C++ unit test framework (yolinux.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c7c702c0abb9">GTEST做C++单元测试初级教程（GTEST Prime译文） - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/215edbfc2e0a">使用GTEST编写C++测试用例进阶教程（GTEST advanced中文译文） - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html">玩转Google开源C++单元测试框架Google Test系列(gtest)(总) - CoderZh - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://notes.maxwi.com/2017/11/29/gtest/">Google Test(gtest)使用 | blueyi's notes (maxwi.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/googletest">google/googletest: GoogleTest - Google Testing and Mocking Framework (github.com)</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/22/C++Debug/C++errorC2039%20/" rel="prev" title="C++ error C2039">
      <i class="fa fa-chevron-left"></i> C++ error C2039
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/22/C++Lib/C++Boost%20string%20algorithm/" rel="next" title="C++ Boost string algorithm 使用">
      C++ Boost string algorithm 使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%AD%E8%A8%80assertions"><span class="nav-number">1.</span> <span class="nav-text">断言(Assertions)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%96%AD%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">基本的断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%96%AD%E8%A8%80"><span class="nav-number">1.2.</span> <span class="nav-text">比较断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="nav-number">1.3.</span> <span class="nav-text">字符串比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%B5%8B%E8%AF%95%E4%BE%8B%E5%AD%90"><span class="nav-number">1.4.</span> <span class="nav-text">简单的测试例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#test-fixtures%E4%B8%BA%E5%A4%9A%E4%B8%AA%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">2.</span> <span class="nav-text">Test Fixtures(为多个测试使用相同的配置)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95"><span class="nav-number">3.</span> <span class="nav-text">调用测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99main%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">编写main()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%B2%E7%9F%A5%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">已知的限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%96%AD%E8%A8%80"><span class="nav-number">6.</span> <span class="nav-text">更多的断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E7%9A%84%E6%88%90%E5%8A%9F%E5%92%8C%E5%A4%B1%E8%B4%A5"><span class="nav-number">6.1.</span> <span class="nav-text">明确的成功和失败</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%AD%E8%A8%80"><span class="nav-number">6.2.</span> <span class="nav-text">异常的断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E6%9B%B4%E5%A5%BD%E5%9C%B0%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E8%80%8C%E4%BD%BF%E7%94%A8%E8%B0%93%E8%AF%8D%E6%96%AD%E8%A8%80"><span class="nav-number">6.3.</span> <span class="nav-text">为了更好地错误信息而使用谓词断言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B8%83%E5%B0%94%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.1.</span> <span class="nav-text">使用一个存在的布尔函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E6%96%AD%E8%A8%80%E7%BB%93%E6%9E%9C%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.2.</span> <span class="nav-text">使用一个返回断言结果的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%B0%93%E8%AF%8D%E6%A0%BC%E5%BC%8F%E5%99%A8"><span class="nav-number">6.3.3.</span> <span class="nav-text">使用谓词格式器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E8%BE%83"><span class="nav-number">6.4.</span> <span class="nav-text">浮点数比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%AE%8F"><span class="nav-number">6.4.1.</span> <span class="nav-text">浮点宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D%E6%A0%BC%E5%BC%8F%E5%87%BD%E6%95%B0"><span class="nav-number">6.4.2.</span> <span class="nav-text">浮点类型谓词格式函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8gmock%E5%8C%B9%E9%85%8D%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%96%AD%E8%A8%80"><span class="nav-number">6.5.</span> <span class="nav-text">使用gMock匹配器进行断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%AD%E8%A8%80"><span class="nav-number">6.6.</span> <span class="nav-text">更多的字符串断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windows-hresult%E6%96%AD%E8%A8%80"><span class="nav-number">6.7.</span> <span class="nav-text">Windows HRESULT断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">6.8.</span> <span class="nav-text">类型断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">6.9.</span> <span class="nav-text">断言的位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%99gtest%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E4%BD%A0%E7%9A%84%E5%80%BC"><span class="nav-number">7.</span> <span class="nav-text">教GTEST如何打印你的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1%E6%B5%8B%E8%AF%95"><span class="nav-number">8.</span> <span class="nav-text">死亡测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%AD%BB%E4%BA%A1%E6%B5%8B%E8%AF%95"><span class="nav-number">8.1.</span> <span class="nav-text">如何编写死亡测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1%E6%B5%8B%E8%AF%95%E5%91%BD%E5%90%8D"><span class="nav-number">8.2.</span> <span class="nav-text">死亡测试命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-number">8.3.</span> <span class="nav-text">死亡测试如何工作的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1%E6%B5%8B%E8%AF%95%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">8.4.</span> <span class="nav-text">死亡测试和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.5.</span> <span class="nav-text">死亡测试类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AD%A6%E5%91%8A"><span class="nav-number">8.6.</span> <span class="nav-text">警告</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%AD%90%E4%BE%8B%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80"><span class="nav-number">9.</span> <span class="nav-text">在子例程中使用断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E6%96%AD%E8%A8%80%E6%B7%BB%E5%8A%A0%E8%B7%9F%E8%B8%AA"><span class="nav-number">9.1.</span> <span class="nav-text">向断言添加跟踪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E8%87%B4%E5%91%BD%E9%94%99%E8%AF%AF"><span class="nav-number">9.2.</span> <span class="nav-text">传递致命错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E9%A2%9D%E5%A4%96%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">10.</span> <span class="nav-text">记录额外的信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E7%9B%B8%E5%90%8C%E6%B5%8B%E8%AF%95%E5%A5%97%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">11.</span> <span class="nav-text">在相同测试套件中的不同测试之间共享资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80setup%E5%92%8Cteardown"><span class="nav-number">12.</span> <span class="nav-text">全局SetUp和TearDown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="nav-number">13.</span> <span class="nav-text">值参数化测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%80%BC%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="nav-number">13.1.</span> <span class="nav-text">如何编写值参数化测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%80%BC%E5%8F%82%E6%95%B0%E5%8C%96%E6%8A%BD%E8%B1%A1%E6%B5%8B%E8%AF%95"><span class="nav-number">13.2.</span> <span class="nav-text">创建值参数化抽象测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%80%BC%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E6%B5%8B%E8%AF%95%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E5%90%8D%E7%A7%B0"><span class="nav-number">13.3.</span> <span class="nav-text">为值参数化的测试参数指定名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95"><span class="nav-number">14.</span> <span class="nav-text">类型测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="nav-number">15.</span> <span class="nav-text">类型参数化测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95private%E4%BB%A3%E7%A0%81"><span class="nav-number">16.</span> <span class="nav-text">测试private代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%A4%B1%E8%B4%A5"><span class="nav-number">17.</span> <span class="nav-text">捕获失败</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%9A%84%E6%B3%A8%E5%86%8C%E6%B5%8B%E8%AF%95"><span class="nav-number">18.</span> <span class="nav-text">程序化的注册测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9A%84%E6%B5%8B%E8%AF%95%E5%90%8D"><span class="nav-number">19.</span> <span class="nav-text">获取当前的测试名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%A4%84%E7%90%86%E6%B5%8B%E8%AF%95%E4%BA%8B%E4%BB%B6%E6%9D%A5%E6%89%A9%E5%B1%95googletest"><span class="nav-number">20.</span> <span class="nav-text">通过处理测试事件来扩展googletest</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">20.1.</span> <span class="nav-text">定义事件监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">20.2.</span> <span class="nav-text">使用事件监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%A4%B1%E8%B4%A5%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">20.3.</span> <span class="nav-text">生成失败监听器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%A4%9A%E9%80%89%E9%A1%B9"><span class="nav-number">21.</span> <span class="nav-text">运行测试程序：更多选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%B5%8B%E8%AF%95"><span class="nav-number">21.1.</span> <span class="nav-text">选择测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%B5%8B%E8%AF%95"><span class="nav-number">21.2.</span> <span class="nav-text">重复测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B1%E5%BA%8F%E6%B5%8B%E8%AF%95"><span class="nav-number">21.3.</span> <span class="nav-text">乱序测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">21.4.</span> <span class="nav-text">控制测试的输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%A6%82%E4%BD%95%E6%8A%A5%E5%91%8A%E5%A4%B1%E8%B4%A5"><span class="nav-number">21.5.</span> <span class="nav-text">控制如何报告失败</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83"><span class="nav-number">22.</span> <span class="nav-text">相关参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">straywriter</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">124</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/straywriter" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;straywriter" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">straywriter</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
